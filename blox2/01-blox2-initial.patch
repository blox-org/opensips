From 2fdefe5b30051dd62d1407de3ad107e47bb656f0 Mon Sep 17 00:00:00 2001
From: Varadhan M <varadhan@cem-solutions.net>
Date: Wed, 9 Aug 2017 04:23:21 -0700
Subject: Added patch for blox2

---
 db/schema/load_balancer.xml                 |   12 +
 etc/opensips.conf.rsyslog                   |    2 +
 etc/opensips.logrotate                      |    8 +
 fastlock.h                                  |   11 +
 modules/b2b_entities/client.c               |    2 +-
 modules/call_center/call_center.c           |    3 +-
 modules/fraud_detection/fraud_detection.c   |    2 +-
 modules/ipops/Makefile                      |   14 +
 modules/ipops/README                        |  301 ++
 modules/ipops/compile_ip_parser.rl.sh       |   21 +
 modules/ipops/compile_rfc1918_parser.rl.sh  |   21 +
 modules/ipops/doc/Makefile                  |    4 +
 modules/ipops/doc/ipops.xml                 |   34 +
 modules/ipops/doc/ipops_admin.xml           |  484 +++
 modules/ipops/ip_parser.c                   | 5955 +++++++++++++++++++++++++++
 modules/ipops/ip_parser.h                   |   24 +
 modules/ipops/ip_parser.rl                  |   65 +
 modules/ipops/ipops_mod.c                   |  593 +++
 modules/ipops/rfc1918_parser.c              |  399 ++
 modules/ipops/rfc1918_parser.h              |   16 +
 modules/ipops/rfc1918_parser.rl             |   43 +
 modules/load_balancer/lb_data.c             |    3 +-
 modules/load_balancer/lb_data.h             |    3 +-
 modules/load_balancer/lb_db.c               |   38 +-
 modules/load_balancer/lb_db.h               |    1 +
 modules/load_balancer/lb_prober.c           |   17 +-
 modules/python/python_iface.c               |   17 +
 modules/regex/regex_mod.c                   |   34 +-
 modules/rtpengine/rtpengine.c               |    2 +
 modules/sipmsgops/sipmsgops.c               |  161 +
 modules/topology_hiding/topo_hiding_logic.c |   37 +
 modules/topology_hiding/topology_hiding.c   |   12 +
 modules/uac_subclient/Makefile              |   10 +
 modules/uac_subclient/README                |  341 ++
 modules/uac_subclient/sub_db_handler.c      |  422 ++
 modules/uac_subclient/sub_db_handler.h      |   76 +
 modules/uac_subclient/sub_records.c         |  286 ++
 modules/uac_subclient/sub_records.h         |  105 +
 modules/uac_subclient/subclient.c           |  928 +++++
 parser/parse_content.h                      |    2 +
 parser/sdp/sdp_helpr_funcs.c                |   15 +
 scripts/mysql/load_balancer-create.sql      |    1 +
 scripts/mysql/subclient-create.sql          |   17 +
 scripts/opensipsctl                         |   11 +-
 scripts/opensipsctlrc                       |   19 +-
 scripts/opensipsdbctl.base                  |    4 +-
 transformations.c                           |    6 +
 47 files changed, 10548 insertions(+), 34 deletions(-)
 create mode 100644 etc/opensips.conf.rsyslog
 create mode 100644 etc/opensips.logrotate
 create mode 100644 modules/ipops/Makefile
 create mode 100644 modules/ipops/README
 create mode 100755 modules/ipops/compile_ip_parser.rl.sh
 create mode 100755 modules/ipops/compile_rfc1918_parser.rl.sh
 create mode 100644 modules/ipops/doc/Makefile
 create mode 100644 modules/ipops/doc/ipops.xml
 create mode 100644 modules/ipops/doc/ipops_admin.xml
 create mode 100644 modules/ipops/ip_parser.c
 create mode 100644 modules/ipops/ip_parser.h
 create mode 100644 modules/ipops/ip_parser.rl
 create mode 100644 modules/ipops/ipops_mod.c
 create mode 100644 modules/ipops/rfc1918_parser.c
 create mode 100644 modules/ipops/rfc1918_parser.h
 create mode 100644 modules/ipops/rfc1918_parser.rl
 create mode 100644 modules/uac_subclient/Makefile
 create mode 100644 modules/uac_subclient/README
 create mode 100644 modules/uac_subclient/sub_db_handler.c
 create mode 100644 modules/uac_subclient/sub_db_handler.h
 create mode 100644 modules/uac_subclient/sub_records.c
 create mode 100644 modules/uac_subclient/sub_records.h
 create mode 100644 modules/uac_subclient/subclient.c
 create mode 100644 scripts/mysql/subclient-create.sql

diff --git a/db/schema/load_balancer.xml b/db/schema/load_balancer.xml
index 9898763..184b0a0 100644
--- a/db/schema/load_balancer.xml
+++ b/db/schema/load_balancer.xml
@@ -61,6 +61,18 @@
 		<description>Probing mode (0-none, 1-if disabled, 2-all the time)</description>
 	</column>
 
+	<column>
+		<name>socket</name>
+		<type>string</type>
+		<size>128</size>
+		<null/>
+		<default><null/></default>
+		<description>Local Socket to be used when sending requests (traffic and probes)
+		to the destination - must be an listener configured in opensips.
+		</description>
+	</column>
+
+
 	<column id="description">
 		<name>description</name>
 		<type>string</type>
diff --git a/etc/opensips.conf.rsyslog b/etc/opensips.conf.rsyslog
new file mode 100644
index 0000000..a6e04fd
--- /dev/null
+++ b/etc/opensips.conf.rsyslog
@@ -0,0 +1,2 @@
+local0.*                               -/var/log/opensips.log
+local0.info                            -/var/log/lcr.log
diff --git a/etc/opensips.logrotate b/etc/opensips.logrotate
new file mode 100644
index 0000000..5049e02
--- /dev/null
+++ b/etc/opensips.logrotate
@@ -0,0 +1,8 @@
+/var/log/opensips.log
+/var/log/lcr.log {
+    size 100M
+    sharedscripts
+    postrotate
+	/bin/kill -HUP `cat /var/run/syslogd.pid 2>/dev/null` 2>/dev/null || true
+    endscript
+}
diff --git a/fastlock.h b/fastlock.h
index 758c430..b49f3da 100644
--- a/fastlock.h
+++ b/fastlock.h
@@ -115,10 +115,21 @@ inline static int tsl(volatile int* lock)
 
 #elif defined __CPU_arm
 	asm volatile(
+#ifdef __CPU_armv7l
+			"   ldrex %0, [%2] \n\t" 
+			"   cmp %0, #0 \n\t"
+			"   it eq \n\t"
+			"   strexeq %0, %3, [%2] \n\t" /* executed only if Z=1 */
+			/* if %0!=0 => either it was 1 initially or was 0
+			 * and somebody changed it just before the strexeq (so the 
+			 * lock is taken) => it's safe to return %0 */
+			: "=&r"(val), "=m"(*lock) : "r"(lock), "r"(1) : "cc"
+#else
 			"# here \n\t"
 			"swpb %0, %1, [%2] \n\t"
 			: "=&r" (val)
 			: "r"(1), "r" (lock) : "memory"
+#endif
 	);
 
 #elif defined(__CPU_ppc) || defined(__CPU_ppc64)
diff --git a/modules/b2b_entities/client.c b/modules/b2b_entities/client.c
index 10e064a..87b71a2 100644
--- a/modules/b2b_entities/client.c
+++ b/modules/b2b_entities/client.c
@@ -88,7 +88,7 @@ str* client_new(client_info_t* ci,b2b_notify_t b2b_cback,
 	str ehdr = {0, 0};
 	str* b2b_key_shm = NULL;
 	dlg_t td;
-	str from_tag;
+	str from_tag = {0, 0};
 	str random_info = {0, 0};
 
 	if(ci == NULL || b2b_cback == NULL || param== NULL)
diff --git a/modules/call_center/call_center.c b/modules/call_center/call_center.c
index a748cc5..bc0cec1 100755
--- a/modules/call_center/call_center.c
+++ b/modules/call_center/call_center.c
@@ -483,7 +483,8 @@ int b2bl_callback_customer(b2bl_cb_params_t *params, unsigned int event)
 	str leg = {NULL,0};
 	call_state cs;
 	int cnt;
-	b2bl_dlg_stat_t* stat = params->stat;
+	b2bl_dlg_stat_t  empty_stat = {{0,0},0,0,0};
+	b2bl_dlg_stat_t* stat = params->stat?params->stat:&empty_stat;
 
 	LM_DBG(" call (%p) has event %d, \n", call, event);
 
diff --git a/modules/fraud_detection/fraud_detection.c b/modules/fraud_detection/fraud_detection.c
index d0e236b..8b95d2f 100644
--- a/modules/fraud_detection/fraud_detection.c
+++ b/modules/fraud_detection/fraud_detection.c
@@ -399,7 +399,7 @@ static int check_fraud(struct sip_msg *msg, char *_user, char *_number, char *_p
 	frd_thresholds_t *thr = (frd_thresholds_t*)rule->attrs.s;
 
 #define CHECK_AND_RAISE(pname, type) \
-	(se->stats.pname >= thr->pname ## _thr.type) { \
+	(thr->pname ## _thr.type > 0 && se->stats.pname >= thr->pname ## _thr.type) { \
 		raise_ ## type ## _event(&pname ## _name, &se->stats.pname,\
 				&thr->pname ## _thr.type, &user, &number, &rule->id);\
 		rc = rc_ ## type ## _thr;\
diff --git a/modules/ipops/Makefile b/modules/ipops/Makefile
new file mode 100644
index 0000000..12f3691
--- /dev/null
+++ b/modules/ipops/Makefile
@@ -0,0 +1,14 @@
+#
+# ipops Module
+#
+#
+# WARNING: do not run this directly, it should be run by the master Makefile
+
+include ../../Makefile.defs
+auto_gen=
+NAME=ipops.so
+
+LIBS=
+DEFS+=-DOPENSER_MOD_INTERFACE
+SERLIBPATH=../../lib
+include ../../Makefile.modules
\ No newline at end of file
diff --git a/modules/ipops/README b/modules/ipops/README
new file mode 100644
index 0000000..798bcea
--- /dev/null
+++ b/modules/ipops/README
@@ -0,0 +1,301 @@
+ipops Module
+
+Iñaki Baz Castillo
+
+   <ibc@aliax.net>
+
+Edited by
+
+Iñaki Baz Castillo
+
+   <ibc@aliax.net>
+
+   Copyright © 2011 Iñaki Baz Castillo
+     __________________________________________________________________
+
+   Table of Contents
+
+   1. Admin Guide
+
+        1. Overview
+        2. Dependencies
+
+              2.1. SIP Router Modules
+              2.2. External Libraries or Applications
+
+        3. Parameters
+        4. Functions
+
+              4.1. is_ip (ip)
+              4.2. is_pure_ip (ip)
+              4.3. is_ipv4 (ip)
+              4.4. is_ipv6 (ip)
+              4.5. is_ipv6_reference (ip)
+              4.6. ip_type (ip)
+              4.7. compare_ips (ip1, ip2)
+              4.8. compare_pure_ips (ip1, ip2)
+              4.9. is_ip_rfc1918 (ip)
+
+   List of Examples
+
+   1.1. is_ip usage
+   1.2. is_pure_ip usage
+   1.3. is_ipv4 usage
+   1.4. is_ipv6 usage
+   1.5. is_ipv6_reference usage
+   1.6. ip_type usage
+   1.7. compare_ips usage
+   1.8. compare_pure_ips usage
+   1.9. is_ip_rfc1918 usage
+
+Chapter 1. Admin Guide
+
+   Table of Contents
+
+   1. Overview
+   2. Dependencies
+
+        2.1. SIP Router Modules
+        2.2. External Libraries or Applications
+
+   3. Parameters
+   4. Functions
+
+        4.1. is_ip (ip)
+        4.2. is_pure_ip (ip)
+        4.3. is_ipv4 (ip)
+        4.4. is_ipv6 (ip)
+        4.5. is_ipv6_reference (ip)
+        4.6. ip_type (ip)
+        4.7. compare_ips (ip1, ip2)
+        4.8. compare_pure_ips (ip1, ip2)
+        4.9. is_ip_rfc1918 (ip)
+
+1. Overview
+
+   This module offers operations for IPv4 and IPv6.
+
+   IPv6 is defined in RFC 2460. The same IPv6 can be represented by
+   different ASCII strings, so binary comparison is required. For example,
+   the following IPv6 are equivalent:
+     * 1080:0000:0000:0000:0008:0800:200C:417A
+     * 1080:0:0:0:8:800:200C:417A
+     * 1080::8:800:200C:417A
+
+   When using IPv6 in an URI (i.e. a SIP URI) such IP must be written in
+   "IPv6 reference" format (which is the textual representation of the
+   IPv6 enclosed between [ ] symbols). An example is
+   “sip:alice@[1080:0:0:0:8:800:200C:417A]”. This module also allows
+   comparing a IPv6 with its IPv6 reference representation.
+
+2. Dependencies
+
+   2.1. SIP Router Modules
+   2.2. External Libraries or Applications
+
+2.1. SIP Router Modules
+
+   The following modules must be loaded before this module:
+     * No dependencies on other SIP Router modules
+
+2.2. External Libraries or Applications
+
+   The following libraries or applications must be installed before
+   running SIP Router with this module loaded:
+     * No dependencies on external libraries
+
+3. Parameters
+
+4. Functions
+
+   4.1. is_ip (ip)
+   4.2. is_pure_ip (ip)
+   4.3. is_ipv4 (ip)
+   4.4. is_ipv6 (ip)
+   4.5. is_ipv6_reference (ip)
+   4.6. ip_type (ip)
+   4.7. compare_ips (ip1, ip2)
+   4.8. compare_pure_ips (ip1, ip2)
+   4.9. is_ip_rfc1918 (ip)
+
+4.1.  is_ip (ip)
+
+   Returns TRUE if the argument is a valid IPv4, IPv6 or IPv6 reference.
+   FALSE otherwise.
+
+   Parameters:
+     * ip - String or pseudo-variable containing the IP to evaluate.
+
+   This function can be used from REQUEST_ROUTE, FAILURE_ROUTE,
+   ONREPLY_ROUTE, BRANCH_ROUTE and LOCAL_ROUTE.
+
+   Example 1.1.  is_ip usage
+...
+if (is_ip($rd)) {
+  xlog("L_INFO", "RURI domain is IP\n");
+}
+...
+
+4.2.  is_pure_ip (ip)
+
+   Returns TRUE if the argument is a valid IPv4 or IPv6. FALSE otherwise.
+
+   Parameters:
+     * ip - String or pseudo-variable containing the IP to evaluate.
+
+   This function can be used from REQUEST_ROUTE, FAILURE_ROUTE,
+   ONREPLY_ROUTE, BRANCH_ROUTE and LOCAL_ROUTE.
+
+   Example 1.2.  is_pure_ip usage
+...
+$var(ip) = "::1";
+if (is_pure_ip($var(ip))) {
+  xlog("L_INFO", "it's IPv4 or IPv6\n");
+}
+...
+
+4.3.  is_ipv4 (ip)
+
+   Returns TRUE if the argument is a valid IPv4. FALSE otherwise.
+
+   Parameters:
+     * ip - String or pseudo-variable containing the IP to evaluate.
+
+   This function can be used from REQUEST_ROUTE, FAILURE_ROUTE,
+   ONREPLY_ROUTE, BRANCH_ROUTE and LOCAL_ROUTE.
+
+   Example 1.3.  is_ipv4 usage
+...
+if (is_ipv4("1.2.3.4")) {
+  xlog("L_INFO", "it's IPv4\n");
+}
+...
+
+4.4.  is_ipv6 (ip)
+
+   Returns TRUE if the argument is a valid IPv6. FALSE otherwise.
+
+   Parameters:
+     * ip - String or pseudo-variable containing the IP to evaluate.
+
+   This function can be used from REQUEST_ROUTE, FAILURE_ROUTE,
+   ONREPLY_ROUTE, BRANCH_ROUTE and LOCAL_ROUTE.
+
+   Example 1.4.  is_ipv6 usage
+...
+if (is_ipv6("1080:0:0:0:8:800:200C:417A")) {
+  xlog("L_INFO", "it's IPv6\n");
+}
+...
+
+4.5.  is_ipv6_reference (ip)
+
+   Returns TRUE if the argument is a valid IPv6 reference. FALSE
+   otherwise.
+
+   Parameters:
+     * ip - String or pseudo-variable containing the IP to evaluate.
+
+   This function can be used from REQUEST_ROUTE, FAILURE_ROUTE,
+   ONREPLY_ROUTE, BRANCH_ROUTE and LOCAL_ROUTE.
+
+   Example 1.5.  is_ipv6_reference usage
+...
+if (is_ipv6_reference("[1080:0:0:0:8:800:200C:417A]")) {
+  xlog("L_INFO", "it's IPv6 reference\n");
+}
+...
+
+4.6.  ip_type (ip)
+
+   Returns the type of the given IP.
+
+   Parameters:
+     * ip - String or pseudo-variable containing the IP to evaluate.
+
+   Return value:
+     * 1 - IPv4
+     * 2 - IPv6
+     * 3 - IPv6 reference
+     * -1 - invalid IP
+
+   This function can be used from REQUEST_ROUTE, FAILURE_ROUTE,
+   ONREPLY_ROUTE, BRANCH_ROUTE and LOCAL_ROUTE.
+
+   Example 1.6.  ip_type usage
+...
+ip_type($var(myip));
+switch($rc) {
+  case 1:
+    xlog("L_INFO", "it's IPv4\n");
+    break;
+  case 2:
+    xlog("L_INFO", "it's IPv6\n");
+    break;
+  case 3:
+    xlog("L_INFO", "it's IPv6 reference\n");
+    break;
+  case -1:
+    xlog("L_INFO", it's type invalid\n");
+    break;
+}
+...
+
+4.7.  compare_ips (ip1, ip2)
+
+   Returns TRUE if both IP's are the same. FALSE otherwise. This function
+   also allows comparing an IPv6 against an IPv6 reference.
+
+   Parameters:
+     * ip1 - String or pseudo-variable containing the first IP to compare.
+     * ip2 - String or pseudo-variable containing the second IP to
+       compare.
+
+   This function can be used from REQUEST_ROUTE, FAILURE_ROUTE,
+   ONREPLY_ROUTE, BRANCH_ROUTE and LOCAL_ROUTE.
+
+   Example 1.7.  compare_ips usage
+...
+if (compare_ips("1080:0000:0000:0000:0008:0800:200C:417A", "[1080::8:800:200C:41
+7A]")) {
+  xlog("L_INFO", "both are the same IP\n");
+}
+...
+
+4.8.  compare_pure_ips (ip1, ip2)
+
+   Returns TRUE if both IP's are the same. FALSE otherwise. This function
+   does NOT allow comparing an IPv6 against an IPv6 reference.
+
+   Parameters:
+     * ip1 - String or pseudo-variable containing the first IP to compare.
+     * ip2 - String or pseudo-variable containing the second IP to
+       compare.
+
+   This function can be used from REQUEST_ROUTE, FAILURE_ROUTE,
+   ONREPLY_ROUTE, BRANCH_ROUTE and LOCAL_ROUTE.
+
+   Example 1.8.  compare_pure_ips usage
+...
+if (compare_pure_ips($si, "1080::8:800:200C:417A")) {
+  xlog("L_INFO", "both are the same IP\n");
+}
+...
+
+4.9.  is_ip_rfc1918 (ip)
+
+   Returns TRUE if the argument is a private IPv4 according to RFC 1918.
+   FALSE otherwise.
+
+   Parameters:
+     * ip - String or pseudo-variable containing the IP to evaluate.
+
+   This function can be used from REQUEST_ROUTE, FAILURE_ROUTE,
+   ONREPLY_ROUTE, BRANCH_ROUTE and LOCAL_ROUTE.
+
+   Example 1.9.  is_ip_rfc1918 usage
+...
+if (is_ip_rfc1918("10.0.123.123")) {
+  xlog("L_INFO", "it's a private IPv4\n");
+}
+...
diff --git a/modules/ipops/compile_ip_parser.rl.sh b/modules/ipops/compile_ip_parser.rl.sh
new file mode 100755
index 0000000..963a38e
--- /dev/null
+++ b/modules/ipops/compile_ip_parser.rl.sh
@@ -0,0 +1,21 @@
+#!/bin/bash
+
+
+which ragel >/dev/null
+if [ $? -ne 0 ] ; then
+  echo "ERROR. Ragel not installed, cannot compile the Ragel grammar." >&2
+  exit 1
+else
+  ragel -v
+  echo
+fi
+
+
+set -e
+
+RAGEL_FILE=ip_parser
+echo ">>> Compiling Ragel grammar $RAGEL_FILE.rl ..."
+ragel -G2 -C $RAGEL_FILE.rl
+echo
+echo "<<< OK: $RAGEL_FILE.c generated"
+echo
diff --git a/modules/ipops/compile_rfc1918_parser.rl.sh b/modules/ipops/compile_rfc1918_parser.rl.sh
new file mode 100755
index 0000000..be2a750
--- /dev/null
+++ b/modules/ipops/compile_rfc1918_parser.rl.sh
@@ -0,0 +1,21 @@
+#!/bin/bash
+
+
+which ragel >/dev/null
+if [ $? -ne 0 ] ; then
+  echo "ERROR. Ragel not installed, cannot compile the Ragel grammar." >&2
+  exit 1
+else
+  ragel -v
+  echo
+fi
+
+
+set -e
+
+RAGEL_FILE=rfc1918_parser
+echo ">>> Compiling Ragel grammar $RAGEL_FILE.rl ..."
+ragel -G2 -C $RAGEL_FILE.rl
+echo
+echo "<<< OK: $RAGEL_FILE.c generated"
+echo
diff --git a/modules/ipops/doc/Makefile b/modules/ipops/doc/Makefile
new file mode 100644
index 0000000..7ff9fce
--- /dev/null
+++ b/modules/ipops/doc/Makefile
@@ -0,0 +1,4 @@
+docs = ipops.xml
+
+docbook_dir = ../../../docbook
+include $(docbook_dir)/Makefile.module
diff --git a/modules/ipops/doc/ipops.xml b/modules/ipops/doc/ipops.xml
new file mode 100644
index 0000000..ea18038
--- /dev/null
+++ b/modules/ipops/doc/ipops.xml
@@ -0,0 +1,34 @@
+<?xml version="1.0" encoding='UTF-8'?>
+<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
+"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd" [
+
+ <!-- Include general documentation entities -->
+ <!ENTITY % docentities SYSTEM "../../../docbook/entities.xml">
+ %docentities;
+ 
+]>
+   
+<book xmlns:xi="http://www.w3.org/2001/XInclude">
+  <bookinfo>
+    <title>ipops Module</title>
+    <authorgroup>
+      <author>
+        <firstname>Iñaki</firstname>
+        <surname>Baz Castillo</surname>
+        <email>ibc@aliax.net</email>
+      </author>
+      <editor>
+        <firstname>Iñaki</firstname>
+        <surname>Baz Castillo</surname>
+        <email>ibc@aliax.net</email>
+      </editor>
+    </authorgroup>
+    <copyright>
+      <year>2011</year>
+      <holder>Iñaki Baz Castillo</holder>
+    </copyright>
+  </bookinfo>
+  <toc>
+  </toc>
+  <xi:include href="ipops_admin.xml"/>
+</book>
diff --git a/modules/ipops/doc/ipops_admin.xml b/modules/ipops/doc/ipops_admin.xml
new file mode 100644
index 0000000..efec34c
--- /dev/null
+++ b/modules/ipops/doc/ipops_admin.xml
@@ -0,0 +1,484 @@
+<?xml version="1.0" encoding='ISO-8859-1'?>
+<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
+"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd" [
+
+<!-- Include general documentation entities -->
+<!ENTITY % docentities SYSTEM "../../../docbook/entities.xml">
+%docentities;
+ 
+]>
+
+<!-- Module User's Guide -->
+     
+<chapter>
+
+  <title>&adminguide;</title>
+       
+  <section>
+         
+    <title>Overview</title>
+         
+    <para>
+      This module offers operations for IPv4 and IPv6.
+    </para>
+
+    <para>
+      IPv6 is defined in <ulink url="http://tools.ietf.org/html/rfc2460">RFC 2460</ulink>. The same IPv6 can be represented by different ASCII strings, so binary comparison is required. For example, the following IPv6 are equivalent:
+    </para>
+
+    <itemizedlist>
+      <listitem>
+        <para>1080:0000:0000:0000:0008:0800:200C:417A</para>
+      </listitem>
+      <listitem>
+        <para>1080:0:0:0:8:800:200C:417A</para>
+      </listitem>
+      <listitem>
+        <para>1080::8:800:200C:417A</para>
+      </listitem>
+    </itemizedlist>
+
+    <para>
+      When using IPv6 in an URI (i.e. a SIP URI) such IP must be written in "IPv6 reference" format (which is the textual representation of the IPv6 enclosed between [ ] symbols). An example is <quote>sip:alice@[1080:0:0:0:8:800:200C:417A]</quote>. This module also allows comparing a IPv6 with its IPv6 reference representation.
+    </para>
+           
+  </section>
+           
+  <section>
+             
+    <title>Dependencies</title>
+             
+    <section>
+      <title>&siprouter; Modules</title>
+      <para>
+        The following modules must be loaded before this module:
+        <itemizedlist>
+          <listitem>
+            <para>
+              <emphasis>No dependencies on other &siprouter; modules</emphasis>
+            </para>
+          </listitem>
+        </itemizedlist>
+      </para>
+    </section>
+               
+    <section>
+      <title>External Libraries or Applications</title>
+      <para>
+        The following libraries or applications must be installed before running &siprouter; with this module loaded:
+        <itemizedlist>
+          <listitem>
+            <para>
+              <emphasis>No dependencies on external libraries</emphasis>
+            </para>
+          </listitem>
+        </itemizedlist>
+      </para>
+    </section>
+             
+  </section>
+           
+  <section>
+
+    <title>Parameters</title>
+             
+  </section>
+           
+  <section>
+
+    <title>Functions</title>
+             
+    <section>
+      <title>
+        <function moreinfo="none">is_ip (ip)</function>
+      </title>
+
+      <para>
+        Returns TRUE if the argument is a valid IPv4, IPv6 or IPv6 reference. FALSE otherwise.
+      </para>
+
+      <para>Parameters:</para>
+
+      <itemizedlist>
+        <listitem>
+          <para>
+            <emphasis>ip</emphasis> - String or pseudo-variable containing the IP to evaluate.
+          </para>
+        </listitem>
+      </itemizedlist>
+
+      <para>
+        This function can be used from REQUEST_ROUTE, FAILURE_ROUTE, ONREPLY_ROUTE, BRANCH_ROUTE and LOCAL_ROUTE.
+      </para>
+
+      <example>
+        <title>
+          <function>is_ip</function> usage
+        </title>
+        <programlisting format="linespecific">
+...
+if (is_ip($rd)) {
+  xlog("L_INFO", "RURI domain is IP\n");
+}
+...
+        </programlisting>
+      </example>
+
+    </section>
+
+    <section>
+      <title>
+        <function moreinfo="none">is_pure_ip (ip)</function>
+      </title>
+
+      <para>
+        Returns TRUE if the argument is a valid IPv4 or IPv6. FALSE otherwise.
+      </para>
+
+      <para>Parameters:</para>
+
+      <itemizedlist>
+        <listitem>
+          <para>
+            <emphasis>ip</emphasis> - String or pseudo-variable containing the IP to evaluate.
+          </para>
+        </listitem>
+      </itemizedlist>
+
+      <para>
+        This function can be used from REQUEST_ROUTE, FAILURE_ROUTE, ONREPLY_ROUTE, BRANCH_ROUTE and LOCAL_ROUTE.
+      </para>
+
+      <example>
+        <title>
+          <function>is_pure_ip</function> usage
+        </title>
+        <programlisting format="linespecific">
+...
+$var(ip) = "::1";
+if (is_pure_ip($var(ip))) {
+  xlog("L_INFO", "it's IPv4 or IPv6\n");
+}
+...
+        </programlisting>
+      </example>
+
+    </section>
+
+    <section>
+      <title>
+        <function moreinfo="none">is_ipv4 (ip)</function>
+      </title>
+
+      <para>
+        Returns TRUE if the argument is a valid IPv4. FALSE otherwise.
+      </para>
+
+      <para>Parameters:</para>
+
+      <itemizedlist>
+        <listitem>
+          <para>
+            <emphasis>ip</emphasis> - String or pseudo-variable containing the IP to evaluate.
+          </para>
+        </listitem>
+      </itemizedlist>
+
+      <para>
+        This function can be used from REQUEST_ROUTE, FAILURE_ROUTE, ONREPLY_ROUTE, BRANCH_ROUTE and LOCAL_ROUTE.
+      </para>
+
+      <example>
+        <title>
+          <function>is_ipv4</function> usage
+        </title>
+        <programlisting format="linespecific">
+...
+if (is_ipv4("1.2.3.4")) {
+  xlog("L_INFO", "it's IPv4\n");
+}
+...
+        </programlisting>
+      </example>
+
+    </section>
+
+    <section>
+      <title>
+        <function moreinfo="none">is_ipv6 (ip)</function>
+      </title>
+
+      <para>
+        Returns TRUE if the argument is a valid IPv6. FALSE otherwise.
+      </para>
+
+      <para>Parameters:</para>
+
+      <itemizedlist>
+        <listitem>
+          <para>
+            <emphasis>ip</emphasis> - String or pseudo-variable containing the IP to evaluate.
+          </para>
+        </listitem>
+      </itemizedlist>
+
+      <para>
+        This function can be used from REQUEST_ROUTE, FAILURE_ROUTE, ONREPLY_ROUTE, BRANCH_ROUTE and LOCAL_ROUTE.
+      </para>
+
+      <example>
+        <title>
+          <function>is_ipv6</function> usage
+        </title>
+        <programlisting format="linespecific">
+...
+if (is_ipv6("1080:0:0:0:8:800:200C:417A")) {
+  xlog("L_INFO", "it's IPv6\n");
+}
+...
+        </programlisting>
+      </example>
+
+    </section>
+
+    <section>
+      <title>
+        <function moreinfo="none">is_ipv6_reference (ip)</function>
+      </title>
+
+      <para>
+        Returns TRUE if the argument is a valid IPv6 reference. FALSE otherwise.
+      </para>
+
+      <para>Parameters:</para>
+
+      <itemizedlist>
+        <listitem>
+          <para>
+            <emphasis>ip</emphasis> - String or pseudo-variable containing the IP to evaluate.
+          </para>
+        </listitem>
+      </itemizedlist>
+
+      <para>
+        This function can be used from REQUEST_ROUTE, FAILURE_ROUTE, ONREPLY_ROUTE, BRANCH_ROUTE and LOCAL_ROUTE.
+      </para>
+
+      <example>
+        <title>
+          <function>is_ipv6_reference</function> usage
+        </title>
+        <programlisting format="linespecific">
+...
+if (is_ipv6_reference("[1080:0:0:0:8:800:200C:417A]")) {
+  xlog("L_INFO", "it's IPv6 reference\n");
+}
+...
+        </programlisting>
+      </example>
+
+    </section>
+
+    <section>
+      <title>
+        <function moreinfo="none">ip_type (ip)</function>
+      </title>
+
+      <para>
+        Returns the type of the given IP.
+      </para>
+
+      <para>Parameters:</para>
+
+      <itemizedlist>
+        <listitem>
+          <para>
+            <emphasis>ip</emphasis> - String or pseudo-variable containing the IP to evaluate.
+          </para>
+        </listitem>
+      </itemizedlist>
+
+      <para>Return value:</para>
+
+      <itemizedlist>
+        <listitem>
+          <para>
+            <emphasis>1</emphasis> - IPv4
+          </para>
+        </listitem>
+        <listitem>
+          <para>
+            <emphasis>2</emphasis> - IPv6
+          </para>
+        </listitem>
+        <listitem>
+          <para>
+            <emphasis>3</emphasis> - IPv6 reference
+          </para>
+        </listitem>
+        <listitem>
+          <para>
+            <emphasis>-1</emphasis> - invalid IP
+          </para>
+        </listitem>
+      </itemizedlist>
+
+      <para>
+        This function can be used from REQUEST_ROUTE, FAILURE_ROUTE, ONREPLY_ROUTE, BRANCH_ROUTE and LOCAL_ROUTE.
+      </para>
+
+      <example>
+        <title>
+          <function>ip_type</function> usage
+        </title>
+        <programlisting format="linespecific">
+...
+ip_type($var(myip));
+switch($rc) {
+  case 1:
+    xlog("L_INFO", "it's IPv4\n");
+    break;
+  case 2:
+    xlog("L_INFO", "it's IPv6\n");
+    break;
+  case 3:
+    xlog("L_INFO", "it's IPv6 reference\n");
+    break;
+  case -1:
+    xlog("L_INFO", it's type invalid\n");
+    break;
+}
+...
+        </programlisting>
+      </example>
+
+    </section>
+
+    <section>
+      <title>
+        <function moreinfo="none">compare_ips (ip1, ip2)</function>
+      </title>
+
+      <para>
+        Returns TRUE if both IP's are the same. FALSE otherwise. This function also allows comparing an IPv6 against an IPv6 reference.
+      </para>
+
+      <para>Parameters:</para>
+
+      <itemizedlist>
+        <listitem>
+          <para>
+            <emphasis>ip1</emphasis> - String or pseudo-variable containing the first IP to compare.
+          </para>
+        </listitem>
+        <listitem>
+          <para>
+            <emphasis>ip2</emphasis> - String or pseudo-variable containing the second IP to compare.
+          </para>
+        </listitem>
+      </itemizedlist>
+
+      <para>
+        This function can be used from REQUEST_ROUTE, FAILURE_ROUTE, ONREPLY_ROUTE, BRANCH_ROUTE and LOCAL_ROUTE.
+      </para>
+
+      <example>
+        <title>
+          <function>compare_ips</function> usage
+        </title>
+        <programlisting format="linespecific">
+...
+if (compare_ips("1080:0000:0000:0000:0008:0800:200C:417A", "[1080::8:800:200C:417A]")) {
+  xlog("L_INFO", "both are the same IP\n");
+}
+...
+        </programlisting>
+      </example>
+
+    </section>
+
+    <section>
+      <title>
+        <function moreinfo="none">compare_pure_ips (ip1, ip2)</function>
+      </title>
+
+      <para>
+        Returns TRUE if both IP's are the same. FALSE otherwise. This function does NOT allow comparing an IPv6 against an IPv6 reference.
+      </para>
+
+      <para>Parameters:</para>
+
+      <itemizedlist>
+        <listitem>
+          <para>
+            <emphasis>ip1</emphasis> - String or pseudo-variable containing the first IP to compare.
+          </para>
+        </listitem>
+        <listitem>
+          <para>
+            <emphasis>ip2</emphasis> - String or pseudo-variable containing the second IP to compare.
+          </para>
+        </listitem>
+      </itemizedlist>
+
+      <para>
+        This function can be used from REQUEST_ROUTE, FAILURE_ROUTE, ONREPLY_ROUTE, BRANCH_ROUTE and LOCAL_ROUTE.
+      </para>
+
+      <example>
+        <title>
+          <function>compare_pure_ips</function> usage
+        </title>
+        <programlisting format="linespecific">
+...
+if (compare_pure_ips($si, "1080::8:800:200C:417A")) {
+  xlog("L_INFO", "both are the same IP\n");
+}
+...
+        </programlisting>
+      </example>
+
+    </section>
+
+    <section>
+      <title>
+        <function moreinfo="none">is_ip_rfc1918 (ip)</function>
+      </title>
+
+      <para>
+        Returns TRUE if the argument is a private IPv4 according to RFC 1918. FALSE otherwise.
+      </para>
+
+      <para>Parameters:</para>
+
+      <itemizedlist>
+        <listitem>
+          <para>
+            <emphasis>ip</emphasis> - String or pseudo-variable containing the IP to evaluate.
+          </para>
+        </listitem>
+      </itemizedlist>
+
+      <para>
+        This function can be used from REQUEST_ROUTE, FAILURE_ROUTE, ONREPLY_ROUTE, BRANCH_ROUTE and LOCAL_ROUTE.
+      </para>
+
+      <example>
+        <title>
+          <function>is_ip_rfc1918</function> usage
+        </title>
+        <programlisting format="linespecific">
+...
+if (is_ip_rfc1918("10.0.123.123")) {
+  xlog("L_INFO", "it's a private IPv4\n");
+}
+...
+        </programlisting>
+      </example>
+
+    </section>
+ 
+
+  </section>
+ 
+</chapter>
diff --git a/modules/ipops/ip_parser.c b/modules/ipops/ip_parser.c
new file mode 100644
index 0000000..b9e0a1c
--- /dev/null
+++ b/modules/ipops/ip_parser.c
@@ -0,0 +1,5955 @@
+/*
+ * Warning: This file is auto generated from a ragel syntax (ip_parser.rl),
+ * do not change it!
+ */
+
+#line 1 "ip_parser.rl"
+#include "ip_parser.h"
+
+
+/** Ragel machine **/
+
+#line 41 "ip_parser.rl"
+
+
+/** Data **/
+
+#line 14 "ip_parser.c"
+static const int ip_parser_start = 1;
+static const int ip_parser_first_final = 237;
+static const int ip_parser_error = 0;
+
+static const int ip_parser_en_main = 1;
+
+
+#line 45 "ip_parser.rl"
+
+
+/** exec **/
+enum enum_ip_type ip_parser_execute(const char *str, size_t len)
+{
+  int cs = 0;
+  const char *p, *pe;
+  enum enum_ip_type ip_type = ip_type_error;
+
+  p = str;
+  pe = str+len;
+
+  
+#line 36 "ip_parser.c"
+	{
+	cs = ip_parser_start;
+	}
+
+#line 58 "ip_parser.rl"
+  
+#line 43 "ip_parser.c"
+	{
+	if ( p == pe )
+		goto _test_eof;
+	switch ( cs )
+	{
+case 1:
+	switch( (*p) ) {
+		case 48: goto st2;
+		case 49: goto st76;
+		case 50: goto st79;
+		case 58: goto st83;
+		case 91: goto st86;
+	}
+	if ( (*p) < 65 ) {
+		if ( 51 <= (*p) && (*p) <= 57 )
+			goto st82;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st85;
+	} else
+		goto st85;
+	goto st0;
+st0:
+cs = 0;
+	goto _out;
+st2:
+	if ( ++p == pe )
+		goto _test_eof2;
+case 2:
+	switch( (*p) ) {
+		case 46: goto st3;
+		case 58: goto st19;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st16;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st16;
+	} else
+		goto st16;
+	goto st0;
+st3:
+	if ( ++p == pe )
+		goto _test_eof3;
+case 3:
+	switch( (*p) ) {
+		case 48: goto st4;
+		case 49: goto st12;
+		case 50: goto st14;
+	}
+	if ( 51 <= (*p) && (*p) <= 57 )
+		goto st13;
+	goto st0;
+st4:
+	if ( ++p == pe )
+		goto _test_eof4;
+case 4:
+	if ( (*p) == 46 )
+		goto st5;
+	goto st0;
+st5:
+	if ( ++p == pe )
+		goto _test_eof5;
+case 5:
+	switch( (*p) ) {
+		case 48: goto st6;
+		case 49: goto st8;
+		case 50: goto st10;
+	}
+	if ( 51 <= (*p) && (*p) <= 57 )
+		goto st9;
+	goto st0;
+st6:
+	if ( ++p == pe )
+		goto _test_eof6;
+case 6:
+	if ( (*p) == 46 )
+		goto st7;
+	goto st0;
+st7:
+	if ( ++p == pe )
+		goto _test_eof7;
+case 7:
+	switch( (*p) ) {
+		case 48: goto tr21;
+		case 49: goto tr22;
+		case 50: goto tr23;
+	}
+	if ( 51 <= (*p) && (*p) <= 57 )
+		goto tr24;
+	goto st0;
+tr21:
+#line 8 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv4;
+  }
+	goto st237;
+tr78:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st237;
+tr180:
+#line 16 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6_reference;
+  }
+	goto st237;
+st237:
+	if ( ++p == pe )
+		goto _test_eof237;
+case 237:
+#line 158 "ip_parser.c"
+	goto st0;
+tr22:
+#line 8 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv4;
+  }
+	goto st238;
+st238:
+	if ( ++p == pe )
+		goto _test_eof238;
+case 238:
+#line 170 "ip_parser.c"
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto tr24;
+	goto st0;
+tr24:
+#line 8 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv4;
+  }
+	goto st239;
+st239:
+	if ( ++p == pe )
+		goto _test_eof239;
+case 239:
+#line 184 "ip_parser.c"
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto tr21;
+	goto st0;
+tr23:
+#line 8 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv4;
+  }
+	goto st240;
+st240:
+	if ( ++p == pe )
+		goto _test_eof240;
+case 240:
+#line 198 "ip_parser.c"
+	if ( (*p) == 53 )
+		goto tr272;
+	if ( (*p) > 52 ) {
+		if ( 54 <= (*p) && (*p) <= 57 )
+			goto tr21;
+	} else if ( (*p) >= 48 )
+		goto tr24;
+	goto st0;
+tr272:
+#line 8 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv4;
+  }
+	goto st241;
+st241:
+	if ( ++p == pe )
+		goto _test_eof241;
+case 241:
+#line 217 "ip_parser.c"
+	if ( 48 <= (*p) && (*p) <= 53 )
+		goto tr21;
+	goto st0;
+st8:
+	if ( ++p == pe )
+		goto _test_eof8;
+case 8:
+	if ( (*p) == 46 )
+		goto st7;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st9;
+	goto st0;
+st9:
+	if ( ++p == pe )
+		goto _test_eof9;
+case 9:
+	if ( (*p) == 46 )
+		goto st7;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st6;
+	goto st0;
+st10:
+	if ( ++p == pe )
+		goto _test_eof10;
+case 10:
+	switch( (*p) ) {
+		case 46: goto st7;
+		case 53: goto st11;
+	}
+	if ( (*p) > 52 ) {
+		if ( 54 <= (*p) && (*p) <= 57 )
+			goto st6;
+	} else if ( (*p) >= 48 )
+		goto st9;
+	goto st0;
+st11:
+	if ( ++p == pe )
+		goto _test_eof11;
+case 11:
+	if ( (*p) == 46 )
+		goto st7;
+	if ( 48 <= (*p) && (*p) <= 53 )
+		goto st6;
+	goto st0;
+st12:
+	if ( ++p == pe )
+		goto _test_eof12;
+case 12:
+	if ( (*p) == 46 )
+		goto st5;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st13;
+	goto st0;
+st13:
+	if ( ++p == pe )
+		goto _test_eof13;
+case 13:
+	if ( (*p) == 46 )
+		goto st5;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st4;
+	goto st0;
+st14:
+	if ( ++p == pe )
+		goto _test_eof14;
+case 14:
+	switch( (*p) ) {
+		case 46: goto st5;
+		case 53: goto st15;
+	}
+	if ( (*p) > 52 ) {
+		if ( 54 <= (*p) && (*p) <= 57 )
+			goto st4;
+	} else if ( (*p) >= 48 )
+		goto st13;
+	goto st0;
+st15:
+	if ( ++p == pe )
+		goto _test_eof15;
+case 15:
+	if ( (*p) == 46 )
+		goto st5;
+	if ( 48 <= (*p) && (*p) <= 53 )
+		goto st4;
+	goto st0;
+st16:
+	if ( ++p == pe )
+		goto _test_eof16;
+case 16:
+	if ( (*p) == 58 )
+		goto st19;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st17;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st17;
+	} else
+		goto st17;
+	goto st0;
+st17:
+	if ( ++p == pe )
+		goto _test_eof17;
+case 17:
+	if ( (*p) == 58 )
+		goto st19;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st18;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st18;
+	} else
+		goto st18;
+	goto st0;
+st18:
+	if ( ++p == pe )
+		goto _test_eof18;
+case 18:
+	if ( (*p) == 58 )
+		goto st19;
+	goto st0;
+st19:
+	if ( ++p == pe )
+		goto _test_eof19;
+case 19:
+	if ( (*p) == 58 )
+		goto tr30;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st20;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st20;
+	} else
+		goto st20;
+	goto st0;
+st20:
+	if ( ++p == pe )
+		goto _test_eof20;
+case 20:
+	if ( (*p) == 58 )
+		goto st24;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st21;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st21;
+	} else
+		goto st21;
+	goto st0;
+st21:
+	if ( ++p == pe )
+		goto _test_eof21;
+case 21:
+	if ( (*p) == 58 )
+		goto st24;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st22;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st22;
+	} else
+		goto st22;
+	goto st0;
+st22:
+	if ( ++p == pe )
+		goto _test_eof22;
+case 22:
+	if ( (*p) == 58 )
+		goto st24;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st23;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st23;
+	} else
+		goto st23;
+	goto st0;
+st23:
+	if ( ++p == pe )
+		goto _test_eof23;
+case 23:
+	if ( (*p) == 58 )
+		goto st24;
+	goto st0;
+st24:
+	if ( ++p == pe )
+		goto _test_eof24;
+case 24:
+	if ( (*p) == 58 )
+		goto tr36;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st25;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st25;
+	} else
+		goto st25;
+	goto st0;
+st25:
+	if ( ++p == pe )
+		goto _test_eof25;
+case 25:
+	if ( (*p) == 58 )
+		goto st29;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st26;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st26;
+	} else
+		goto st26;
+	goto st0;
+st26:
+	if ( ++p == pe )
+		goto _test_eof26;
+case 26:
+	if ( (*p) == 58 )
+		goto st29;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st27;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st27;
+	} else
+		goto st27;
+	goto st0;
+st27:
+	if ( ++p == pe )
+		goto _test_eof27;
+case 27:
+	if ( (*p) == 58 )
+		goto st29;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st28;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st28;
+	} else
+		goto st28;
+	goto st0;
+st28:
+	if ( ++p == pe )
+		goto _test_eof28;
+case 28:
+	if ( (*p) == 58 )
+		goto st29;
+	goto st0;
+st29:
+	if ( ++p == pe )
+		goto _test_eof29;
+case 29:
+	if ( (*p) == 58 )
+		goto tr42;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st30;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st30;
+	} else
+		goto st30;
+	goto st0;
+st30:
+	if ( ++p == pe )
+		goto _test_eof30;
+case 30:
+	if ( (*p) == 58 )
+		goto st34;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st31;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st31;
+	} else
+		goto st31;
+	goto st0;
+st31:
+	if ( ++p == pe )
+		goto _test_eof31;
+case 31:
+	if ( (*p) == 58 )
+		goto st34;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st32;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st32;
+	} else
+		goto st32;
+	goto st0;
+st32:
+	if ( ++p == pe )
+		goto _test_eof32;
+case 32:
+	if ( (*p) == 58 )
+		goto st34;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st33;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st33;
+	} else
+		goto st33;
+	goto st0;
+st33:
+	if ( ++p == pe )
+		goto _test_eof33;
+case 33:
+	if ( (*p) == 58 )
+		goto st34;
+	goto st0;
+st34:
+	if ( ++p == pe )
+		goto _test_eof34;
+case 34:
+	if ( (*p) == 58 )
+		goto tr48;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st35;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st35;
+	} else
+		goto st35;
+	goto st0;
+st35:
+	if ( ++p == pe )
+		goto _test_eof35;
+case 35:
+	if ( (*p) == 58 )
+		goto st39;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st36;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st36;
+	} else
+		goto st36;
+	goto st0;
+st36:
+	if ( ++p == pe )
+		goto _test_eof36;
+case 36:
+	if ( (*p) == 58 )
+		goto st39;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st37;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st37;
+	} else
+		goto st37;
+	goto st0;
+st37:
+	if ( ++p == pe )
+		goto _test_eof37;
+case 37:
+	if ( (*p) == 58 )
+		goto st39;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st38;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st38;
+	} else
+		goto st38;
+	goto st0;
+st38:
+	if ( ++p == pe )
+		goto _test_eof38;
+case 38:
+	if ( (*p) == 58 )
+		goto st39;
+	goto st0;
+st39:
+	if ( ++p == pe )
+		goto _test_eof39;
+case 39:
+	if ( (*p) == 58 )
+		goto tr54;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st40;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st40;
+	} else
+		goto st40;
+	goto st0;
+st40:
+	if ( ++p == pe )
+		goto _test_eof40;
+case 40:
+	if ( (*p) == 58 )
+		goto st44;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st41;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st41;
+	} else
+		goto st41;
+	goto st0;
+st41:
+	if ( ++p == pe )
+		goto _test_eof41;
+case 41:
+	if ( (*p) == 58 )
+		goto st44;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st42;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st42;
+	} else
+		goto st42;
+	goto st0;
+st42:
+	if ( ++p == pe )
+		goto _test_eof42;
+case 42:
+	if ( (*p) == 58 )
+		goto st44;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st43;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st43;
+	} else
+		goto st43;
+	goto st0;
+st43:
+	if ( ++p == pe )
+		goto _test_eof43;
+case 43:
+	if ( (*p) == 58 )
+		goto st44;
+	goto st0;
+st44:
+	if ( ++p == pe )
+		goto _test_eof44;
+case 44:
+	switch( (*p) ) {
+		case 48: goto st45;
+		case 49: goto st63;
+		case 50: goto st66;
+		case 58: goto tr63;
+	}
+	if ( (*p) < 65 ) {
+		if ( 51 <= (*p) && (*p) <= 57 )
+			goto st69;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st70;
+	} else
+		goto st70;
+	goto st0;
+st45:
+	if ( ++p == pe )
+		goto _test_eof45;
+case 45:
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 58: goto st62;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st59;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st59;
+	} else
+		goto st59;
+	goto st0;
+st46:
+	if ( ++p == pe )
+		goto _test_eof46;
+case 46:
+	switch( (*p) ) {
+		case 48: goto st47;
+		case 49: goto st55;
+		case 50: goto st57;
+	}
+	if ( 51 <= (*p) && (*p) <= 57 )
+		goto st56;
+	goto st0;
+st47:
+	if ( ++p == pe )
+		goto _test_eof47;
+case 47:
+	if ( (*p) == 46 )
+		goto st48;
+	goto st0;
+st48:
+	if ( ++p == pe )
+		goto _test_eof48;
+case 48:
+	switch( (*p) ) {
+		case 48: goto st49;
+		case 49: goto st51;
+		case 50: goto st53;
+	}
+	if ( 51 <= (*p) && (*p) <= 57 )
+		goto st52;
+	goto st0;
+st49:
+	if ( ++p == pe )
+		goto _test_eof49;
+case 49:
+	if ( (*p) == 46 )
+		goto st50;
+	goto st0;
+st50:
+	if ( ++p == pe )
+		goto _test_eof50;
+case 50:
+	switch( (*p) ) {
+		case 48: goto tr78;
+		case 49: goto tr79;
+		case 50: goto tr80;
+	}
+	if ( 51 <= (*p) && (*p) <= 57 )
+		goto tr81;
+	goto st0;
+tr79:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st242;
+st242:
+	if ( ++p == pe )
+		goto _test_eof242;
+case 242:
+#line 771 "ip_parser.c"
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto tr81;
+	goto st0;
+tr81:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st243;
+st243:
+	if ( ++p == pe )
+		goto _test_eof243;
+case 243:
+#line 785 "ip_parser.c"
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto tr78;
+	goto st0;
+tr80:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st244;
+st244:
+	if ( ++p == pe )
+		goto _test_eof244;
+case 244:
+#line 799 "ip_parser.c"
+	if ( (*p) == 53 )
+		goto tr273;
+	if ( (*p) > 52 ) {
+		if ( 54 <= (*p) && (*p) <= 57 )
+			goto tr78;
+	} else if ( (*p) >= 48 )
+		goto tr81;
+	goto st0;
+tr273:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st245;
+st245:
+	if ( ++p == pe )
+		goto _test_eof245;
+case 245:
+#line 818 "ip_parser.c"
+	if ( 48 <= (*p) && (*p) <= 53 )
+		goto tr78;
+	goto st0;
+st51:
+	if ( ++p == pe )
+		goto _test_eof51;
+case 51:
+	if ( (*p) == 46 )
+		goto st50;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st52;
+	goto st0;
+st52:
+	if ( ++p == pe )
+		goto _test_eof52;
+case 52:
+	if ( (*p) == 46 )
+		goto st50;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st49;
+	goto st0;
+st53:
+	if ( ++p == pe )
+		goto _test_eof53;
+case 53:
+	switch( (*p) ) {
+		case 46: goto st50;
+		case 53: goto st54;
+	}
+	if ( (*p) > 52 ) {
+		if ( 54 <= (*p) && (*p) <= 57 )
+			goto st49;
+	} else if ( (*p) >= 48 )
+		goto st52;
+	goto st0;
+st54:
+	if ( ++p == pe )
+		goto _test_eof54;
+case 54:
+	if ( (*p) == 46 )
+		goto st50;
+	if ( 48 <= (*p) && (*p) <= 53 )
+		goto st49;
+	goto st0;
+st55:
+	if ( ++p == pe )
+		goto _test_eof55;
+case 55:
+	if ( (*p) == 46 )
+		goto st48;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st56;
+	goto st0;
+st56:
+	if ( ++p == pe )
+		goto _test_eof56;
+case 56:
+	if ( (*p) == 46 )
+		goto st48;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st47;
+	goto st0;
+st57:
+	if ( ++p == pe )
+		goto _test_eof57;
+case 57:
+	switch( (*p) ) {
+		case 46: goto st48;
+		case 53: goto st58;
+	}
+	if ( (*p) > 52 ) {
+		if ( 54 <= (*p) && (*p) <= 57 )
+			goto st47;
+	} else if ( (*p) >= 48 )
+		goto st56;
+	goto st0;
+st58:
+	if ( ++p == pe )
+		goto _test_eof58;
+case 58:
+	if ( (*p) == 46 )
+		goto st48;
+	if ( 48 <= (*p) && (*p) <= 53 )
+		goto st47;
+	goto st0;
+st59:
+	if ( ++p == pe )
+		goto _test_eof59;
+case 59:
+	if ( (*p) == 58 )
+		goto st62;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st60;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st60;
+	} else
+		goto st60;
+	goto st0;
+st60:
+	if ( ++p == pe )
+		goto _test_eof60;
+case 60:
+	if ( (*p) == 58 )
+		goto st62;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st61;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st61;
+	} else
+		goto st61;
+	goto st0;
+st61:
+	if ( ++p == pe )
+		goto _test_eof61;
+case 61:
+	if ( (*p) == 58 )
+		goto st62;
+	goto st0;
+st62:
+	if ( ++p == pe )
+		goto _test_eof62;
+case 62:
+	if ( (*p) == 58 )
+		goto tr78;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr86;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr86;
+	} else
+		goto tr86;
+	goto st0;
+tr86:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st246;
+st246:
+	if ( ++p == pe )
+		goto _test_eof246;
+case 246:
+#line 966 "ip_parser.c"
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr274;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr274;
+	} else
+		goto tr274;
+	goto st0;
+tr274:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st247;
+st247:
+	if ( ++p == pe )
+		goto _test_eof247;
+case 247:
+#line 986 "ip_parser.c"
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr275;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr275;
+	} else
+		goto tr275;
+	goto st0;
+tr275:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st248;
+st248:
+	if ( ++p == pe )
+		goto _test_eof248;
+case 248:
+#line 1006 "ip_parser.c"
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr78;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr78;
+	} else
+		goto tr78;
+	goto st0;
+st63:
+	if ( ++p == pe )
+		goto _test_eof63;
+case 63:
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 58: goto st62;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st64;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st59;
+	} else
+		goto st59;
+	goto st0;
+st64:
+	if ( ++p == pe )
+		goto _test_eof64;
+case 64:
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 58: goto st62;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st65;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st60;
+	} else
+		goto st60;
+	goto st0;
+st65:
+	if ( ++p == pe )
+		goto _test_eof65;
+case 65:
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 58: goto st62;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st61;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st61;
+	} else
+		goto st61;
+	goto st0;
+st66:
+	if ( ++p == pe )
+		goto _test_eof66;
+case 66:
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 53: goto st67;
+		case 58: goto st62;
+	}
+	if ( (*p) < 54 ) {
+		if ( 48 <= (*p) && (*p) <= 52 )
+			goto st64;
+	} else if ( (*p) > 57 ) {
+		if ( (*p) > 70 ) {
+			if ( 97 <= (*p) && (*p) <= 102 )
+				goto st59;
+		} else if ( (*p) >= 65 )
+			goto st59;
+	} else
+		goto st68;
+	goto st0;
+st67:
+	if ( ++p == pe )
+		goto _test_eof67;
+case 67:
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 58: goto st62;
+	}
+	if ( (*p) < 54 ) {
+		if ( 48 <= (*p) && (*p) <= 53 )
+			goto st65;
+	} else if ( (*p) > 57 ) {
+		if ( (*p) > 70 ) {
+			if ( 97 <= (*p) && (*p) <= 102 )
+				goto st60;
+		} else if ( (*p) >= 65 )
+			goto st60;
+	} else
+		goto st60;
+	goto st0;
+st68:
+	if ( ++p == pe )
+		goto _test_eof68;
+case 68:
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 58: goto st62;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st60;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st60;
+	} else
+		goto st60;
+	goto st0;
+st69:
+	if ( ++p == pe )
+		goto _test_eof69;
+case 69:
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 58: goto st62;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st68;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st59;
+	} else
+		goto st59;
+	goto st0;
+tr63:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st249;
+st249:
+	if ( ++p == pe )
+		goto _test_eof249;
+case 249:
+#line 1152 "ip_parser.c"
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr86;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr86;
+	} else
+		goto tr86;
+	goto st0;
+st70:
+	if ( ++p == pe )
+		goto _test_eof70;
+case 70:
+	if ( (*p) == 58 )
+		goto st62;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st59;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st59;
+	} else
+		goto st59;
+	goto st0;
+tr54:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st250;
+st250:
+	if ( ++p == pe )
+		goto _test_eof250;
+case 250:
+#line 1187 "ip_parser.c"
+	switch( (*p) ) {
+		case 48: goto tr91;
+		case 49: goto tr92;
+		case 50: goto tr93;
+	}
+	if ( (*p) < 65 ) {
+		if ( 51 <= (*p) && (*p) <= 57 )
+			goto tr94;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr95;
+	} else
+		goto tr95;
+	goto st0;
+tr91:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st251;
+st251:
+	if ( ++p == pe )
+		goto _test_eof251;
+case 251:
+#line 1212 "ip_parser.c"
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 58: goto st71;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr276;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr276;
+	} else
+		goto tr276;
+	goto st0;
+tr276:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st252;
+st252:
+	if ( ++p == pe )
+		goto _test_eof252;
+case 252:
+#line 1236 "ip_parser.c"
+	if ( (*p) == 58 )
+		goto st71;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr278;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr278;
+	} else
+		goto tr278;
+	goto st0;
+tr278:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st253;
+st253:
+	if ( ++p == pe )
+		goto _test_eof253;
+case 253:
+#line 1258 "ip_parser.c"
+	if ( (*p) == 58 )
+		goto st71;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr279;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr279;
+	} else
+		goto tr279;
+	goto st0;
+tr279:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st254;
+st254:
+	if ( ++p == pe )
+		goto _test_eof254;
+case 254:
+#line 1280 "ip_parser.c"
+	if ( (*p) == 58 )
+		goto st71;
+	goto st0;
+st71:
+	if ( ++p == pe )
+		goto _test_eof71;
+case 71:
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr86;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr86;
+	} else
+		goto tr86;
+	goto st0;
+tr92:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st255;
+st255:
+	if ( ++p == pe )
+		goto _test_eof255;
+case 255:
+#line 1307 "ip_parser.c"
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 58: goto st71;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr280;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr276;
+	} else
+		goto tr276;
+	goto st0;
+tr280:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st256;
+st256:
+	if ( ++p == pe )
+		goto _test_eof256;
+case 256:
+#line 1331 "ip_parser.c"
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 58: goto st71;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr281;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr278;
+	} else
+		goto tr278;
+	goto st0;
+tr281:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st257;
+st257:
+	if ( ++p == pe )
+		goto _test_eof257;
+case 257:
+#line 1355 "ip_parser.c"
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 58: goto st71;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr279;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr279;
+	} else
+		goto tr279;
+	goto st0;
+tr93:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st258;
+st258:
+	if ( ++p == pe )
+		goto _test_eof258;
+case 258:
+#line 1379 "ip_parser.c"
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 53: goto tr282;
+		case 58: goto st71;
+	}
+	if ( (*p) < 54 ) {
+		if ( 48 <= (*p) && (*p) <= 52 )
+			goto tr280;
+	} else if ( (*p) > 57 ) {
+		if ( (*p) > 70 ) {
+			if ( 97 <= (*p) && (*p) <= 102 )
+				goto tr276;
+		} else if ( (*p) >= 65 )
+			goto tr276;
+	} else
+		goto tr283;
+	goto st0;
+tr282:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st259;
+st259:
+	if ( ++p == pe )
+		goto _test_eof259;
+case 259:
+#line 1407 "ip_parser.c"
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 58: goto st71;
+	}
+	if ( (*p) < 54 ) {
+		if ( 48 <= (*p) && (*p) <= 53 )
+			goto tr281;
+	} else if ( (*p) > 57 ) {
+		if ( (*p) > 70 ) {
+			if ( 97 <= (*p) && (*p) <= 102 )
+				goto tr278;
+		} else if ( (*p) >= 65 )
+			goto tr278;
+	} else
+		goto tr278;
+	goto st0;
+tr283:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st260;
+st260:
+	if ( ++p == pe )
+		goto _test_eof260;
+case 260:
+#line 1434 "ip_parser.c"
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 58: goto st71;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr278;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr278;
+	} else
+		goto tr278;
+	goto st0;
+tr94:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st261;
+st261:
+	if ( ++p == pe )
+		goto _test_eof261;
+case 261:
+#line 1458 "ip_parser.c"
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 58: goto st71;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr283;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr276;
+	} else
+		goto tr276;
+	goto st0;
+tr95:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st262;
+st262:
+	if ( ++p == pe )
+		goto _test_eof262;
+case 262:
+#line 1482 "ip_parser.c"
+	if ( (*p) == 58 )
+		goto st71;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr276;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr276;
+	} else
+		goto tr276;
+	goto st0;
+tr48:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st263;
+st263:
+	if ( ++p == pe )
+		goto _test_eof263;
+case 263:
+#line 1504 "ip_parser.c"
+	switch( (*p) ) {
+		case 48: goto tr96;
+		case 49: goto tr97;
+		case 50: goto tr98;
+	}
+	if ( (*p) < 65 ) {
+		if ( 51 <= (*p) && (*p) <= 57 )
+			goto tr99;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr100;
+	} else
+		goto tr100;
+	goto st0;
+tr96:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st264;
+st264:
+	if ( ++p == pe )
+		goto _test_eof264;
+case 264:
+#line 1529 "ip_parser.c"
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 58: goto st72;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr284;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr284;
+	} else
+		goto tr284;
+	goto st0;
+tr284:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st265;
+st265:
+	if ( ++p == pe )
+		goto _test_eof265;
+case 265:
+#line 1553 "ip_parser.c"
+	if ( (*p) == 58 )
+		goto st72;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr286;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr286;
+	} else
+		goto tr286;
+	goto st0;
+tr286:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st266;
+st266:
+	if ( ++p == pe )
+		goto _test_eof266;
+case 266:
+#line 1575 "ip_parser.c"
+	if ( (*p) == 58 )
+		goto st72;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr287;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr287;
+	} else
+		goto tr287;
+	goto st0;
+tr287:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st267;
+st267:
+	if ( ++p == pe )
+		goto _test_eof267;
+case 267:
+#line 1597 "ip_parser.c"
+	if ( (*p) == 58 )
+		goto st72;
+	goto st0;
+st72:
+	if ( ++p == pe )
+		goto _test_eof72;
+case 72:
+	switch( (*p) ) {
+		case 48: goto tr91;
+		case 49: goto tr92;
+		case 50: goto tr93;
+	}
+	if ( (*p) < 65 ) {
+		if ( 51 <= (*p) && (*p) <= 57 )
+			goto tr94;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr95;
+	} else
+		goto tr95;
+	goto st0;
+tr97:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st268;
+st268:
+	if ( ++p == pe )
+		goto _test_eof268;
+case 268:
+#line 1629 "ip_parser.c"
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 58: goto st72;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr288;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr284;
+	} else
+		goto tr284;
+	goto st0;
+tr288:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st269;
+st269:
+	if ( ++p == pe )
+		goto _test_eof269;
+case 269:
+#line 1653 "ip_parser.c"
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 58: goto st72;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr289;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr286;
+	} else
+		goto tr286;
+	goto st0;
+tr289:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st270;
+st270:
+	if ( ++p == pe )
+		goto _test_eof270;
+case 270:
+#line 1677 "ip_parser.c"
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 58: goto st72;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr287;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr287;
+	} else
+		goto tr287;
+	goto st0;
+tr98:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st271;
+st271:
+	if ( ++p == pe )
+		goto _test_eof271;
+case 271:
+#line 1701 "ip_parser.c"
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 53: goto tr290;
+		case 58: goto st72;
+	}
+	if ( (*p) < 54 ) {
+		if ( 48 <= (*p) && (*p) <= 52 )
+			goto tr288;
+	} else if ( (*p) > 57 ) {
+		if ( (*p) > 70 ) {
+			if ( 97 <= (*p) && (*p) <= 102 )
+				goto tr284;
+		} else if ( (*p) >= 65 )
+			goto tr284;
+	} else
+		goto tr291;
+	goto st0;
+tr290:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st272;
+st272:
+	if ( ++p == pe )
+		goto _test_eof272;
+case 272:
+#line 1729 "ip_parser.c"
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 58: goto st72;
+	}
+	if ( (*p) < 54 ) {
+		if ( 48 <= (*p) && (*p) <= 53 )
+			goto tr289;
+	} else if ( (*p) > 57 ) {
+		if ( (*p) > 70 ) {
+			if ( 97 <= (*p) && (*p) <= 102 )
+				goto tr286;
+		} else if ( (*p) >= 65 )
+			goto tr286;
+	} else
+		goto tr286;
+	goto st0;
+tr291:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st273;
+st273:
+	if ( ++p == pe )
+		goto _test_eof273;
+case 273:
+#line 1756 "ip_parser.c"
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 58: goto st72;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr286;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr286;
+	} else
+		goto tr286;
+	goto st0;
+tr99:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st274;
+st274:
+	if ( ++p == pe )
+		goto _test_eof274;
+case 274:
+#line 1780 "ip_parser.c"
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 58: goto st72;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr291;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr284;
+	} else
+		goto tr284;
+	goto st0;
+tr100:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st275;
+st275:
+	if ( ++p == pe )
+		goto _test_eof275;
+case 275:
+#line 1804 "ip_parser.c"
+	if ( (*p) == 58 )
+		goto st72;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr284;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr284;
+	} else
+		goto tr284;
+	goto st0;
+tr42:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st276;
+st276:
+	if ( ++p == pe )
+		goto _test_eof276;
+case 276:
+#line 1826 "ip_parser.c"
+	switch( (*p) ) {
+		case 48: goto tr101;
+		case 49: goto tr102;
+		case 50: goto tr103;
+	}
+	if ( (*p) < 65 ) {
+		if ( 51 <= (*p) && (*p) <= 57 )
+			goto tr104;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr105;
+	} else
+		goto tr105;
+	goto st0;
+tr101:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st277;
+st277:
+	if ( ++p == pe )
+		goto _test_eof277;
+case 277:
+#line 1851 "ip_parser.c"
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 58: goto st73;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr292;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr292;
+	} else
+		goto tr292;
+	goto st0;
+tr292:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st278;
+st278:
+	if ( ++p == pe )
+		goto _test_eof278;
+case 278:
+#line 1875 "ip_parser.c"
+	if ( (*p) == 58 )
+		goto st73;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr294;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr294;
+	} else
+		goto tr294;
+	goto st0;
+tr294:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st279;
+st279:
+	if ( ++p == pe )
+		goto _test_eof279;
+case 279:
+#line 1897 "ip_parser.c"
+	if ( (*p) == 58 )
+		goto st73;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr295;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr295;
+	} else
+		goto tr295;
+	goto st0;
+tr295:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st280;
+st280:
+	if ( ++p == pe )
+		goto _test_eof280;
+case 280:
+#line 1919 "ip_parser.c"
+	if ( (*p) == 58 )
+		goto st73;
+	goto st0;
+st73:
+	if ( ++p == pe )
+		goto _test_eof73;
+case 73:
+	switch( (*p) ) {
+		case 48: goto tr96;
+		case 49: goto tr97;
+		case 50: goto tr98;
+	}
+	if ( (*p) < 65 ) {
+		if ( 51 <= (*p) && (*p) <= 57 )
+			goto tr99;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr100;
+	} else
+		goto tr100;
+	goto st0;
+tr102:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st281;
+st281:
+	if ( ++p == pe )
+		goto _test_eof281;
+case 281:
+#line 1951 "ip_parser.c"
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 58: goto st73;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr296;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr292;
+	} else
+		goto tr292;
+	goto st0;
+tr296:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st282;
+st282:
+	if ( ++p == pe )
+		goto _test_eof282;
+case 282:
+#line 1975 "ip_parser.c"
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 58: goto st73;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr297;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr294;
+	} else
+		goto tr294;
+	goto st0;
+tr297:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st283;
+st283:
+	if ( ++p == pe )
+		goto _test_eof283;
+case 283:
+#line 1999 "ip_parser.c"
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 58: goto st73;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr295;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr295;
+	} else
+		goto tr295;
+	goto st0;
+tr103:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st284;
+st284:
+	if ( ++p == pe )
+		goto _test_eof284;
+case 284:
+#line 2023 "ip_parser.c"
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 53: goto tr298;
+		case 58: goto st73;
+	}
+	if ( (*p) < 54 ) {
+		if ( 48 <= (*p) && (*p) <= 52 )
+			goto tr296;
+	} else if ( (*p) > 57 ) {
+		if ( (*p) > 70 ) {
+			if ( 97 <= (*p) && (*p) <= 102 )
+				goto tr292;
+		} else if ( (*p) >= 65 )
+			goto tr292;
+	} else
+		goto tr299;
+	goto st0;
+tr298:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st285;
+st285:
+	if ( ++p == pe )
+		goto _test_eof285;
+case 285:
+#line 2051 "ip_parser.c"
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 58: goto st73;
+	}
+	if ( (*p) < 54 ) {
+		if ( 48 <= (*p) && (*p) <= 53 )
+			goto tr297;
+	} else if ( (*p) > 57 ) {
+		if ( (*p) > 70 ) {
+			if ( 97 <= (*p) && (*p) <= 102 )
+				goto tr294;
+		} else if ( (*p) >= 65 )
+			goto tr294;
+	} else
+		goto tr294;
+	goto st0;
+tr299:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st286;
+st286:
+	if ( ++p == pe )
+		goto _test_eof286;
+case 286:
+#line 2078 "ip_parser.c"
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 58: goto st73;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr294;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr294;
+	} else
+		goto tr294;
+	goto st0;
+tr104:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st287;
+st287:
+	if ( ++p == pe )
+		goto _test_eof287;
+case 287:
+#line 2102 "ip_parser.c"
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 58: goto st73;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr299;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr292;
+	} else
+		goto tr292;
+	goto st0;
+tr105:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st288;
+st288:
+	if ( ++p == pe )
+		goto _test_eof288;
+case 288:
+#line 2126 "ip_parser.c"
+	if ( (*p) == 58 )
+		goto st73;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr292;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr292;
+	} else
+		goto tr292;
+	goto st0;
+tr36:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st289;
+st289:
+	if ( ++p == pe )
+		goto _test_eof289;
+case 289:
+#line 2148 "ip_parser.c"
+	switch( (*p) ) {
+		case 48: goto tr106;
+		case 49: goto tr107;
+		case 50: goto tr108;
+	}
+	if ( (*p) < 65 ) {
+		if ( 51 <= (*p) && (*p) <= 57 )
+			goto tr109;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr110;
+	} else
+		goto tr110;
+	goto st0;
+tr106:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st290;
+st290:
+	if ( ++p == pe )
+		goto _test_eof290;
+case 290:
+#line 2173 "ip_parser.c"
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 58: goto st74;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr300;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr300;
+	} else
+		goto tr300;
+	goto st0;
+tr300:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st291;
+st291:
+	if ( ++p == pe )
+		goto _test_eof291;
+case 291:
+#line 2197 "ip_parser.c"
+	if ( (*p) == 58 )
+		goto st74;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr302;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr302;
+	} else
+		goto tr302;
+	goto st0;
+tr302:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st292;
+st292:
+	if ( ++p == pe )
+		goto _test_eof292;
+case 292:
+#line 2219 "ip_parser.c"
+	if ( (*p) == 58 )
+		goto st74;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr303;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr303;
+	} else
+		goto tr303;
+	goto st0;
+tr303:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st293;
+st293:
+	if ( ++p == pe )
+		goto _test_eof293;
+case 293:
+#line 2241 "ip_parser.c"
+	if ( (*p) == 58 )
+		goto st74;
+	goto st0;
+st74:
+	if ( ++p == pe )
+		goto _test_eof74;
+case 74:
+	switch( (*p) ) {
+		case 48: goto tr101;
+		case 49: goto tr102;
+		case 50: goto tr103;
+	}
+	if ( (*p) < 65 ) {
+		if ( 51 <= (*p) && (*p) <= 57 )
+			goto tr104;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr105;
+	} else
+		goto tr105;
+	goto st0;
+tr107:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st294;
+st294:
+	if ( ++p == pe )
+		goto _test_eof294;
+case 294:
+#line 2273 "ip_parser.c"
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 58: goto st74;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr304;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr300;
+	} else
+		goto tr300;
+	goto st0;
+tr304:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st295;
+st295:
+	if ( ++p == pe )
+		goto _test_eof295;
+case 295:
+#line 2297 "ip_parser.c"
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 58: goto st74;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr305;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr302;
+	} else
+		goto tr302;
+	goto st0;
+tr305:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st296;
+st296:
+	if ( ++p == pe )
+		goto _test_eof296;
+case 296:
+#line 2321 "ip_parser.c"
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 58: goto st74;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr303;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr303;
+	} else
+		goto tr303;
+	goto st0;
+tr108:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st297;
+st297:
+	if ( ++p == pe )
+		goto _test_eof297;
+case 297:
+#line 2345 "ip_parser.c"
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 53: goto tr306;
+		case 58: goto st74;
+	}
+	if ( (*p) < 54 ) {
+		if ( 48 <= (*p) && (*p) <= 52 )
+			goto tr304;
+	} else if ( (*p) > 57 ) {
+		if ( (*p) > 70 ) {
+			if ( 97 <= (*p) && (*p) <= 102 )
+				goto tr300;
+		} else if ( (*p) >= 65 )
+			goto tr300;
+	} else
+		goto tr307;
+	goto st0;
+tr306:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st298;
+st298:
+	if ( ++p == pe )
+		goto _test_eof298;
+case 298:
+#line 2373 "ip_parser.c"
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 58: goto st74;
+	}
+	if ( (*p) < 54 ) {
+		if ( 48 <= (*p) && (*p) <= 53 )
+			goto tr305;
+	} else if ( (*p) > 57 ) {
+		if ( (*p) > 70 ) {
+			if ( 97 <= (*p) && (*p) <= 102 )
+				goto tr302;
+		} else if ( (*p) >= 65 )
+			goto tr302;
+	} else
+		goto tr302;
+	goto st0;
+tr307:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st299;
+st299:
+	if ( ++p == pe )
+		goto _test_eof299;
+case 299:
+#line 2400 "ip_parser.c"
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 58: goto st74;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr302;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr302;
+	} else
+		goto tr302;
+	goto st0;
+tr109:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st300;
+st300:
+	if ( ++p == pe )
+		goto _test_eof300;
+case 300:
+#line 2424 "ip_parser.c"
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 58: goto st74;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr307;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr300;
+	} else
+		goto tr300;
+	goto st0;
+tr110:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st301;
+st301:
+	if ( ++p == pe )
+		goto _test_eof301;
+case 301:
+#line 2448 "ip_parser.c"
+	if ( (*p) == 58 )
+		goto st74;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr300;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr300;
+	} else
+		goto tr300;
+	goto st0;
+tr30:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st302;
+st302:
+	if ( ++p == pe )
+		goto _test_eof302;
+case 302:
+#line 2470 "ip_parser.c"
+	switch( (*p) ) {
+		case 48: goto tr116;
+		case 49: goto tr117;
+		case 50: goto tr118;
+	}
+	if ( (*p) < 65 ) {
+		if ( 51 <= (*p) && (*p) <= 57 )
+			goto tr119;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr120;
+	} else
+		goto tr120;
+	goto st0;
+tr116:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st303;
+st303:
+	if ( ++p == pe )
+		goto _test_eof303;
+case 303:
+#line 2495 "ip_parser.c"
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 58: goto st75;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr308;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr308;
+	} else
+		goto tr308;
+	goto st0;
+tr308:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st304;
+st304:
+	if ( ++p == pe )
+		goto _test_eof304;
+case 304:
+#line 2519 "ip_parser.c"
+	if ( (*p) == 58 )
+		goto st75;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr310;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr310;
+	} else
+		goto tr310;
+	goto st0;
+tr310:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st305;
+st305:
+	if ( ++p == pe )
+		goto _test_eof305;
+case 305:
+#line 2541 "ip_parser.c"
+	if ( (*p) == 58 )
+		goto st75;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr311;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr311;
+	} else
+		goto tr311;
+	goto st0;
+tr311:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st306;
+st306:
+	if ( ++p == pe )
+		goto _test_eof306;
+case 306:
+#line 2563 "ip_parser.c"
+	if ( (*p) == 58 )
+		goto st75;
+	goto st0;
+st75:
+	if ( ++p == pe )
+		goto _test_eof75;
+case 75:
+	switch( (*p) ) {
+		case 48: goto tr106;
+		case 49: goto tr107;
+		case 50: goto tr108;
+	}
+	if ( (*p) < 65 ) {
+		if ( 51 <= (*p) && (*p) <= 57 )
+			goto tr109;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr110;
+	} else
+		goto tr110;
+	goto st0;
+tr117:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st307;
+st307:
+	if ( ++p == pe )
+		goto _test_eof307;
+case 307:
+#line 2595 "ip_parser.c"
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 58: goto st75;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr312;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr308;
+	} else
+		goto tr308;
+	goto st0;
+tr312:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st308;
+st308:
+	if ( ++p == pe )
+		goto _test_eof308;
+case 308:
+#line 2619 "ip_parser.c"
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 58: goto st75;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr313;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr310;
+	} else
+		goto tr310;
+	goto st0;
+tr313:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st309;
+st309:
+	if ( ++p == pe )
+		goto _test_eof309;
+case 309:
+#line 2643 "ip_parser.c"
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 58: goto st75;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr311;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr311;
+	} else
+		goto tr311;
+	goto st0;
+tr118:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st310;
+st310:
+	if ( ++p == pe )
+		goto _test_eof310;
+case 310:
+#line 2667 "ip_parser.c"
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 53: goto tr314;
+		case 58: goto st75;
+	}
+	if ( (*p) < 54 ) {
+		if ( 48 <= (*p) && (*p) <= 52 )
+			goto tr312;
+	} else if ( (*p) > 57 ) {
+		if ( (*p) > 70 ) {
+			if ( 97 <= (*p) && (*p) <= 102 )
+				goto tr308;
+		} else if ( (*p) >= 65 )
+			goto tr308;
+	} else
+		goto tr315;
+	goto st0;
+tr314:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st311;
+st311:
+	if ( ++p == pe )
+		goto _test_eof311;
+case 311:
+#line 2695 "ip_parser.c"
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 58: goto st75;
+	}
+	if ( (*p) < 54 ) {
+		if ( 48 <= (*p) && (*p) <= 53 )
+			goto tr313;
+	} else if ( (*p) > 57 ) {
+		if ( (*p) > 70 ) {
+			if ( 97 <= (*p) && (*p) <= 102 )
+				goto tr310;
+		} else if ( (*p) >= 65 )
+			goto tr310;
+	} else
+		goto tr310;
+	goto st0;
+tr315:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st312;
+st312:
+	if ( ++p == pe )
+		goto _test_eof312;
+case 312:
+#line 2722 "ip_parser.c"
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 58: goto st75;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr310;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr310;
+	} else
+		goto tr310;
+	goto st0;
+tr119:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st313;
+st313:
+	if ( ++p == pe )
+		goto _test_eof313;
+case 313:
+#line 2746 "ip_parser.c"
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 58: goto st75;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr315;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr308;
+	} else
+		goto tr308;
+	goto st0;
+tr120:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st314;
+st314:
+	if ( ++p == pe )
+		goto _test_eof314;
+case 314:
+#line 2770 "ip_parser.c"
+	if ( (*p) == 58 )
+		goto st75;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr308;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr308;
+	} else
+		goto tr308;
+	goto st0;
+st76:
+	if ( ++p == pe )
+		goto _test_eof76;
+case 76:
+	switch( (*p) ) {
+		case 46: goto st3;
+		case 58: goto st19;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st77;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st16;
+	} else
+		goto st16;
+	goto st0;
+st77:
+	if ( ++p == pe )
+		goto _test_eof77;
+case 77:
+	switch( (*p) ) {
+		case 46: goto st3;
+		case 58: goto st19;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st78;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st17;
+	} else
+		goto st17;
+	goto st0;
+st78:
+	if ( ++p == pe )
+		goto _test_eof78;
+case 78:
+	switch( (*p) ) {
+		case 46: goto st3;
+		case 58: goto st19;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st18;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st18;
+	} else
+		goto st18;
+	goto st0;
+st79:
+	if ( ++p == pe )
+		goto _test_eof79;
+case 79:
+	switch( (*p) ) {
+		case 46: goto st3;
+		case 53: goto st80;
+		case 58: goto st19;
+	}
+	if ( (*p) < 54 ) {
+		if ( 48 <= (*p) && (*p) <= 52 )
+			goto st77;
+	} else if ( (*p) > 57 ) {
+		if ( (*p) > 70 ) {
+			if ( 97 <= (*p) && (*p) <= 102 )
+				goto st16;
+		} else if ( (*p) >= 65 )
+			goto st16;
+	} else
+		goto st81;
+	goto st0;
+st80:
+	if ( ++p == pe )
+		goto _test_eof80;
+case 80:
+	switch( (*p) ) {
+		case 46: goto st3;
+		case 58: goto st19;
+	}
+	if ( (*p) < 54 ) {
+		if ( 48 <= (*p) && (*p) <= 53 )
+			goto st78;
+	} else if ( (*p) > 57 ) {
+		if ( (*p) > 70 ) {
+			if ( 97 <= (*p) && (*p) <= 102 )
+				goto st17;
+		} else if ( (*p) >= 65 )
+			goto st17;
+	} else
+		goto st17;
+	goto st0;
+st81:
+	if ( ++p == pe )
+		goto _test_eof81;
+case 81:
+	switch( (*p) ) {
+		case 46: goto st3;
+		case 58: goto st19;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st17;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st17;
+	} else
+		goto st17;
+	goto st0;
+st82:
+	if ( ++p == pe )
+		goto _test_eof82;
+case 82:
+	switch( (*p) ) {
+		case 46: goto st3;
+		case 58: goto st19;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st81;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st16;
+	} else
+		goto st16;
+	goto st0;
+st83:
+	if ( ++p == pe )
+		goto _test_eof83;
+case 83:
+	if ( (*p) == 58 )
+		goto tr115;
+	goto st0;
+tr115:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st315;
+st315:
+	if ( ++p == pe )
+		goto _test_eof315;
+case 315:
+#line 2925 "ip_parser.c"
+	switch( (*p) ) {
+		case 48: goto tr316;
+		case 49: goto tr317;
+		case 50: goto tr318;
+	}
+	if ( (*p) < 65 ) {
+		if ( 51 <= (*p) && (*p) <= 57 )
+			goto tr319;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr320;
+	} else
+		goto tr320;
+	goto st0;
+tr316:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st316;
+st316:
+	if ( ++p == pe )
+		goto _test_eof316;
+case 316:
+#line 2950 "ip_parser.c"
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 58: goto st84;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr321;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr321;
+	} else
+		goto tr321;
+	goto st0;
+tr321:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st317;
+st317:
+	if ( ++p == pe )
+		goto _test_eof317;
+case 317:
+#line 2974 "ip_parser.c"
+	if ( (*p) == 58 )
+		goto st84;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr323;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr323;
+	} else
+		goto tr323;
+	goto st0;
+tr323:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st318;
+st318:
+	if ( ++p == pe )
+		goto _test_eof318;
+case 318:
+#line 2996 "ip_parser.c"
+	if ( (*p) == 58 )
+		goto st84;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr324;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr324;
+	} else
+		goto tr324;
+	goto st0;
+tr324:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st319;
+st319:
+	if ( ++p == pe )
+		goto _test_eof319;
+case 319:
+#line 3018 "ip_parser.c"
+	if ( (*p) == 58 )
+		goto st84;
+	goto st0;
+st84:
+	if ( ++p == pe )
+		goto _test_eof84;
+case 84:
+	switch( (*p) ) {
+		case 48: goto tr116;
+		case 49: goto tr117;
+		case 50: goto tr118;
+	}
+	if ( (*p) < 65 ) {
+		if ( 51 <= (*p) && (*p) <= 57 )
+			goto tr119;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr120;
+	} else
+		goto tr120;
+	goto st0;
+tr317:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st320;
+st320:
+	if ( ++p == pe )
+		goto _test_eof320;
+case 320:
+#line 3050 "ip_parser.c"
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 58: goto st84;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr325;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr321;
+	} else
+		goto tr321;
+	goto st0;
+tr325:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st321;
+st321:
+	if ( ++p == pe )
+		goto _test_eof321;
+case 321:
+#line 3074 "ip_parser.c"
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 58: goto st84;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr326;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr323;
+	} else
+		goto tr323;
+	goto st0;
+tr326:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st322;
+st322:
+	if ( ++p == pe )
+		goto _test_eof322;
+case 322:
+#line 3098 "ip_parser.c"
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 58: goto st84;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr324;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr324;
+	} else
+		goto tr324;
+	goto st0;
+tr318:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st323;
+st323:
+	if ( ++p == pe )
+		goto _test_eof323;
+case 323:
+#line 3122 "ip_parser.c"
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 53: goto tr327;
+		case 58: goto st84;
+	}
+	if ( (*p) < 54 ) {
+		if ( 48 <= (*p) && (*p) <= 52 )
+			goto tr325;
+	} else if ( (*p) > 57 ) {
+		if ( (*p) > 70 ) {
+			if ( 97 <= (*p) && (*p) <= 102 )
+				goto tr321;
+		} else if ( (*p) >= 65 )
+			goto tr321;
+	} else
+		goto tr328;
+	goto st0;
+tr327:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st324;
+st324:
+	if ( ++p == pe )
+		goto _test_eof324;
+case 324:
+#line 3150 "ip_parser.c"
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 58: goto st84;
+	}
+	if ( (*p) < 54 ) {
+		if ( 48 <= (*p) && (*p) <= 53 )
+			goto tr326;
+	} else if ( (*p) > 57 ) {
+		if ( (*p) > 70 ) {
+			if ( 97 <= (*p) && (*p) <= 102 )
+				goto tr323;
+		} else if ( (*p) >= 65 )
+			goto tr323;
+	} else
+		goto tr323;
+	goto st0;
+tr328:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st325;
+st325:
+	if ( ++p == pe )
+		goto _test_eof325;
+case 325:
+#line 3177 "ip_parser.c"
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 58: goto st84;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr323;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr323;
+	} else
+		goto tr323;
+	goto st0;
+tr319:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st326;
+st326:
+	if ( ++p == pe )
+		goto _test_eof326;
+case 326:
+#line 3201 "ip_parser.c"
+	switch( (*p) ) {
+		case 46: goto st46;
+		case 58: goto st84;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr328;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr321;
+	} else
+		goto tr321;
+	goto st0;
+tr320:
+#line 12 "ip_parser.rl"
+	{
+    ip_type = ip_type_ipv6;
+  }
+	goto st327;
+st327:
+	if ( ++p == pe )
+		goto _test_eof327;
+case 327:
+#line 3225 "ip_parser.c"
+	if ( (*p) == 58 )
+		goto st84;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto tr321;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto tr321;
+	} else
+		goto tr321;
+	goto st0;
+st85:
+	if ( ++p == pe )
+		goto _test_eof85;
+case 85:
+	if ( (*p) == 58 )
+		goto st19;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st16;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st16;
+	} else
+		goto st16;
+	goto st0;
+st86:
+	if ( ++p == pe )
+		goto _test_eof86;
+case 86:
+	if ( (*p) == 58 )
+		goto st222;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st87;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st87;
+	} else
+		goto st87;
+	goto st0;
+st87:
+	if ( ++p == pe )
+		goto _test_eof87;
+case 87:
+	if ( (*p) == 58 )
+		goto st91;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st88;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st88;
+	} else
+		goto st88;
+	goto st0;
+st88:
+	if ( ++p == pe )
+		goto _test_eof88;
+case 88:
+	if ( (*p) == 58 )
+		goto st91;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st89;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st89;
+	} else
+		goto st89;
+	goto st0;
+st89:
+	if ( ++p == pe )
+		goto _test_eof89;
+case 89:
+	if ( (*p) == 58 )
+		goto st91;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st90;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st90;
+	} else
+		goto st90;
+	goto st0;
+st90:
+	if ( ++p == pe )
+		goto _test_eof90;
+case 90:
+	if ( (*p) == 58 )
+		goto st91;
+	goto st0;
+st91:
+	if ( ++p == pe )
+		goto _test_eof91;
+case 91:
+	if ( (*p) == 58 )
+		goto st208;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st92;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st92;
+	} else
+		goto st92;
+	goto st0;
+st92:
+	if ( ++p == pe )
+		goto _test_eof92;
+case 92:
+	if ( (*p) == 58 )
+		goto st96;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st93;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st93;
+	} else
+		goto st93;
+	goto st0;
+st93:
+	if ( ++p == pe )
+		goto _test_eof93;
+case 93:
+	if ( (*p) == 58 )
+		goto st96;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st94;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st94;
+	} else
+		goto st94;
+	goto st0;
+st94:
+	if ( ++p == pe )
+		goto _test_eof94;
+case 94:
+	if ( (*p) == 58 )
+		goto st96;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st95;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st95;
+	} else
+		goto st95;
+	goto st0;
+st95:
+	if ( ++p == pe )
+		goto _test_eof95;
+case 95:
+	if ( (*p) == 58 )
+		goto st96;
+	goto st0;
+st96:
+	if ( ++p == pe )
+		goto _test_eof96;
+case 96:
+	if ( (*p) == 58 )
+		goto st194;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st97;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st97;
+	} else
+		goto st97;
+	goto st0;
+st97:
+	if ( ++p == pe )
+		goto _test_eof97;
+case 97:
+	if ( (*p) == 58 )
+		goto st101;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st98;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st98;
+	} else
+		goto st98;
+	goto st0;
+st98:
+	if ( ++p == pe )
+		goto _test_eof98;
+case 98:
+	if ( (*p) == 58 )
+		goto st101;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st99;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st99;
+	} else
+		goto st99;
+	goto st0;
+st99:
+	if ( ++p == pe )
+		goto _test_eof99;
+case 99:
+	if ( (*p) == 58 )
+		goto st101;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st100;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st100;
+	} else
+		goto st100;
+	goto st0;
+st100:
+	if ( ++p == pe )
+		goto _test_eof100;
+case 100:
+	if ( (*p) == 58 )
+		goto st101;
+	goto st0;
+st101:
+	if ( ++p == pe )
+		goto _test_eof101;
+case 101:
+	if ( (*p) == 58 )
+		goto st180;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st102;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st102;
+	} else
+		goto st102;
+	goto st0;
+st102:
+	if ( ++p == pe )
+		goto _test_eof102;
+case 102:
+	if ( (*p) == 58 )
+		goto st106;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st103;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st103;
+	} else
+		goto st103;
+	goto st0;
+st103:
+	if ( ++p == pe )
+		goto _test_eof103;
+case 103:
+	if ( (*p) == 58 )
+		goto st106;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st104;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st104;
+	} else
+		goto st104;
+	goto st0;
+st104:
+	if ( ++p == pe )
+		goto _test_eof104;
+case 104:
+	if ( (*p) == 58 )
+		goto st106;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st105;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st105;
+	} else
+		goto st105;
+	goto st0;
+st105:
+	if ( ++p == pe )
+		goto _test_eof105;
+case 105:
+	if ( (*p) == 58 )
+		goto st106;
+	goto st0;
+st106:
+	if ( ++p == pe )
+		goto _test_eof106;
+case 106:
+	if ( (*p) == 58 )
+		goto st166;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st107;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st107;
+	} else
+		goto st107;
+	goto st0;
+st107:
+	if ( ++p == pe )
+		goto _test_eof107;
+case 107:
+	if ( (*p) == 58 )
+		goto st111;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st108;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st108;
+	} else
+		goto st108;
+	goto st0;
+st108:
+	if ( ++p == pe )
+		goto _test_eof108;
+case 108:
+	if ( (*p) == 58 )
+		goto st111;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st109;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st109;
+	} else
+		goto st109;
+	goto st0;
+st109:
+	if ( ++p == pe )
+		goto _test_eof109;
+case 109:
+	if ( (*p) == 58 )
+		goto st111;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st110;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st110;
+	} else
+		goto st110;
+	goto st0;
+st110:
+	if ( ++p == pe )
+		goto _test_eof110;
+case 110:
+	if ( (*p) == 58 )
+		goto st111;
+	goto st0;
+st111:
+	if ( ++p == pe )
+		goto _test_eof111;
+case 111:
+	if ( (*p) == 58 )
+		goto st152;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st112;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st112;
+	} else
+		goto st112;
+	goto st0;
+st112:
+	if ( ++p == pe )
+		goto _test_eof112;
+case 112:
+	if ( (*p) == 58 )
+		goto st116;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st113;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st113;
+	} else
+		goto st113;
+	goto st0;
+st113:
+	if ( ++p == pe )
+		goto _test_eof113;
+case 113:
+	if ( (*p) == 58 )
+		goto st116;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st114;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st114;
+	} else
+		goto st114;
+	goto st0;
+st114:
+	if ( ++p == pe )
+		goto _test_eof114;
+case 114:
+	if ( (*p) == 58 )
+		goto st116;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st115;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st115;
+	} else
+		goto st115;
+	goto st0;
+st115:
+	if ( ++p == pe )
+		goto _test_eof115;
+case 115:
+	if ( (*p) == 58 )
+		goto st116;
+	goto st0;
+st116:
+	if ( ++p == pe )
+		goto _test_eof116;
+case 116:
+	switch( (*p) ) {
+		case 48: goto st117;
+		case 49: goto st143;
+		case 50: goto st146;
+		case 58: goto st150;
+	}
+	if ( (*p) < 65 ) {
+		if ( 51 <= (*p) && (*p) <= 57 )
+			goto st149;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st151;
+	} else
+		goto st151;
+	goto st0;
+st117:
+	if ( ++p == pe )
+		goto _test_eof117;
+case 117:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 58: goto st139;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st136;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st136;
+	} else
+		goto st136;
+	goto st0;
+st118:
+	if ( ++p == pe )
+		goto _test_eof118;
+case 118:
+	switch( (*p) ) {
+		case 48: goto st119;
+		case 49: goto st132;
+		case 50: goto st134;
+	}
+	if ( 51 <= (*p) && (*p) <= 57 )
+		goto st133;
+	goto st0;
+st119:
+	if ( ++p == pe )
+		goto _test_eof119;
+case 119:
+	if ( (*p) == 46 )
+		goto st120;
+	goto st0;
+st120:
+	if ( ++p == pe )
+		goto _test_eof120;
+case 120:
+	switch( (*p) ) {
+		case 48: goto st121;
+		case 49: goto st128;
+		case 50: goto st130;
+	}
+	if ( 51 <= (*p) && (*p) <= 57 )
+		goto st129;
+	goto st0;
+st121:
+	if ( ++p == pe )
+		goto _test_eof121;
+case 121:
+	if ( (*p) == 46 )
+		goto st122;
+	goto st0;
+st122:
+	if ( ++p == pe )
+		goto _test_eof122;
+case 122:
+	switch( (*p) ) {
+		case 48: goto st123;
+		case 49: goto st124;
+		case 50: goto st126;
+	}
+	if ( 51 <= (*p) && (*p) <= 57 )
+		goto st125;
+	goto st0;
+st123:
+	if ( ++p == pe )
+		goto _test_eof123;
+case 123:
+	if ( (*p) == 93 )
+		goto tr180;
+	goto st0;
+st124:
+	if ( ++p == pe )
+		goto _test_eof124;
+case 124:
+	if ( (*p) == 93 )
+		goto tr180;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st125;
+	goto st0;
+st125:
+	if ( ++p == pe )
+		goto _test_eof125;
+case 125:
+	if ( (*p) == 93 )
+		goto tr180;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st123;
+	goto st0;
+st126:
+	if ( ++p == pe )
+		goto _test_eof126;
+case 126:
+	switch( (*p) ) {
+		case 53: goto st127;
+		case 93: goto tr180;
+	}
+	if ( (*p) > 52 ) {
+		if ( 54 <= (*p) && (*p) <= 57 )
+			goto st123;
+	} else if ( (*p) >= 48 )
+		goto st125;
+	goto st0;
+st127:
+	if ( ++p == pe )
+		goto _test_eof127;
+case 127:
+	if ( (*p) == 93 )
+		goto tr180;
+	if ( 48 <= (*p) && (*p) <= 53 )
+		goto st123;
+	goto st0;
+st128:
+	if ( ++p == pe )
+		goto _test_eof128;
+case 128:
+	if ( (*p) == 46 )
+		goto st122;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st129;
+	goto st0;
+st129:
+	if ( ++p == pe )
+		goto _test_eof129;
+case 129:
+	if ( (*p) == 46 )
+		goto st122;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st121;
+	goto st0;
+st130:
+	if ( ++p == pe )
+		goto _test_eof130;
+case 130:
+	switch( (*p) ) {
+		case 46: goto st122;
+		case 53: goto st131;
+	}
+	if ( (*p) > 52 ) {
+		if ( 54 <= (*p) && (*p) <= 57 )
+			goto st121;
+	} else if ( (*p) >= 48 )
+		goto st129;
+	goto st0;
+st131:
+	if ( ++p == pe )
+		goto _test_eof131;
+case 131:
+	if ( (*p) == 46 )
+		goto st122;
+	if ( 48 <= (*p) && (*p) <= 53 )
+		goto st121;
+	goto st0;
+st132:
+	if ( ++p == pe )
+		goto _test_eof132;
+case 132:
+	if ( (*p) == 46 )
+		goto st120;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st133;
+	goto st0;
+st133:
+	if ( ++p == pe )
+		goto _test_eof133;
+case 133:
+	if ( (*p) == 46 )
+		goto st120;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st119;
+	goto st0;
+st134:
+	if ( ++p == pe )
+		goto _test_eof134;
+case 134:
+	switch( (*p) ) {
+		case 46: goto st120;
+		case 53: goto st135;
+	}
+	if ( (*p) > 52 ) {
+		if ( 54 <= (*p) && (*p) <= 57 )
+			goto st119;
+	} else if ( (*p) >= 48 )
+		goto st133;
+	goto st0;
+st135:
+	if ( ++p == pe )
+		goto _test_eof135;
+case 135:
+	if ( (*p) == 46 )
+		goto st120;
+	if ( 48 <= (*p) && (*p) <= 53 )
+		goto st119;
+	goto st0;
+st136:
+	if ( ++p == pe )
+		goto _test_eof136;
+case 136:
+	if ( (*p) == 58 )
+		goto st139;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st137;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st137;
+	} else
+		goto st137;
+	goto st0;
+st137:
+	if ( ++p == pe )
+		goto _test_eof137;
+case 137:
+	if ( (*p) == 58 )
+		goto st139;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st138;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st138;
+	} else
+		goto st138;
+	goto st0;
+st138:
+	if ( ++p == pe )
+		goto _test_eof138;
+case 138:
+	if ( (*p) == 58 )
+		goto st139;
+	goto st0;
+st139:
+	if ( ++p == pe )
+		goto _test_eof139;
+case 139:
+	if ( (*p) == 58 )
+		goto st123;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st140;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st140;
+	} else
+		goto st140;
+	goto st0;
+st140:
+	if ( ++p == pe )
+		goto _test_eof140;
+case 140:
+	if ( (*p) == 93 )
+		goto tr180;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st141;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st141;
+	} else
+		goto st141;
+	goto st0;
+st141:
+	if ( ++p == pe )
+		goto _test_eof141;
+case 141:
+	if ( (*p) == 93 )
+		goto tr180;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st142;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st142;
+	} else
+		goto st142;
+	goto st0;
+st142:
+	if ( ++p == pe )
+		goto _test_eof142;
+case 142:
+	if ( (*p) == 93 )
+		goto tr180;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st123;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st123;
+	} else
+		goto st123;
+	goto st0;
+st143:
+	if ( ++p == pe )
+		goto _test_eof143;
+case 143:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 58: goto st139;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st144;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st136;
+	} else
+		goto st136;
+	goto st0;
+st144:
+	if ( ++p == pe )
+		goto _test_eof144;
+case 144:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 58: goto st139;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st145;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st137;
+	} else
+		goto st137;
+	goto st0;
+st145:
+	if ( ++p == pe )
+		goto _test_eof145;
+case 145:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 58: goto st139;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st138;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st138;
+	} else
+		goto st138;
+	goto st0;
+st146:
+	if ( ++p == pe )
+		goto _test_eof146;
+case 146:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 53: goto st147;
+		case 58: goto st139;
+	}
+	if ( (*p) < 54 ) {
+		if ( 48 <= (*p) && (*p) <= 52 )
+			goto st144;
+	} else if ( (*p) > 57 ) {
+		if ( (*p) > 70 ) {
+			if ( 97 <= (*p) && (*p) <= 102 )
+				goto st136;
+		} else if ( (*p) >= 65 )
+			goto st136;
+	} else
+		goto st148;
+	goto st0;
+st147:
+	if ( ++p == pe )
+		goto _test_eof147;
+case 147:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 58: goto st139;
+	}
+	if ( (*p) < 54 ) {
+		if ( 48 <= (*p) && (*p) <= 53 )
+			goto st145;
+	} else if ( (*p) > 57 ) {
+		if ( (*p) > 70 ) {
+			if ( 97 <= (*p) && (*p) <= 102 )
+				goto st137;
+		} else if ( (*p) >= 65 )
+			goto st137;
+	} else
+		goto st137;
+	goto st0;
+st148:
+	if ( ++p == pe )
+		goto _test_eof148;
+case 148:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 58: goto st139;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st137;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st137;
+	} else
+		goto st137;
+	goto st0;
+st149:
+	if ( ++p == pe )
+		goto _test_eof149;
+case 149:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 58: goto st139;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st148;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st136;
+	} else
+		goto st136;
+	goto st0;
+st150:
+	if ( ++p == pe )
+		goto _test_eof150;
+case 150:
+	if ( (*p) == 93 )
+		goto tr180;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st140;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st140;
+	} else
+		goto st140;
+	goto st0;
+st151:
+	if ( ++p == pe )
+		goto _test_eof151;
+case 151:
+	if ( (*p) == 58 )
+		goto st139;
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st136;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st136;
+	} else
+		goto st136;
+	goto st0;
+st152:
+	if ( ++p == pe )
+		goto _test_eof152;
+case 152:
+	switch( (*p) ) {
+		case 48: goto st153;
+		case 49: goto st158;
+		case 50: goto st161;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 51 <= (*p) && (*p) <= 57 )
+			goto st164;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st165;
+	} else
+		goto st165;
+	goto st0;
+st153:
+	if ( ++p == pe )
+		goto _test_eof153;
+case 153:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 58: goto st157;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st154;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st154;
+	} else
+		goto st154;
+	goto st0;
+st154:
+	if ( ++p == pe )
+		goto _test_eof154;
+case 154:
+	switch( (*p) ) {
+		case 58: goto st157;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st155;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st155;
+	} else
+		goto st155;
+	goto st0;
+st155:
+	if ( ++p == pe )
+		goto _test_eof155;
+case 155:
+	switch( (*p) ) {
+		case 58: goto st157;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st156;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st156;
+	} else
+		goto st156;
+	goto st0;
+st156:
+	if ( ++p == pe )
+		goto _test_eof156;
+case 156:
+	switch( (*p) ) {
+		case 58: goto st157;
+		case 93: goto tr180;
+	}
+	goto st0;
+st157:
+	if ( ++p == pe )
+		goto _test_eof157;
+case 157:
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st140;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st140;
+	} else
+		goto st140;
+	goto st0;
+st158:
+	if ( ++p == pe )
+		goto _test_eof158;
+case 158:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 58: goto st157;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st159;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st154;
+	} else
+		goto st154;
+	goto st0;
+st159:
+	if ( ++p == pe )
+		goto _test_eof159;
+case 159:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 58: goto st157;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st160;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st155;
+	} else
+		goto st155;
+	goto st0;
+st160:
+	if ( ++p == pe )
+		goto _test_eof160;
+case 160:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 58: goto st157;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st156;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st156;
+	} else
+		goto st156;
+	goto st0;
+st161:
+	if ( ++p == pe )
+		goto _test_eof161;
+case 161:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 53: goto st162;
+		case 58: goto st157;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 54 ) {
+		if ( 48 <= (*p) && (*p) <= 52 )
+			goto st159;
+	} else if ( (*p) > 57 ) {
+		if ( (*p) > 70 ) {
+			if ( 97 <= (*p) && (*p) <= 102 )
+				goto st154;
+		} else if ( (*p) >= 65 )
+			goto st154;
+	} else
+		goto st163;
+	goto st0;
+st162:
+	if ( ++p == pe )
+		goto _test_eof162;
+case 162:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 58: goto st157;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 54 ) {
+		if ( 48 <= (*p) && (*p) <= 53 )
+			goto st160;
+	} else if ( (*p) > 57 ) {
+		if ( (*p) > 70 ) {
+			if ( 97 <= (*p) && (*p) <= 102 )
+				goto st155;
+		} else if ( (*p) >= 65 )
+			goto st155;
+	} else
+		goto st155;
+	goto st0;
+st163:
+	if ( ++p == pe )
+		goto _test_eof163;
+case 163:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 58: goto st157;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st155;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st155;
+	} else
+		goto st155;
+	goto st0;
+st164:
+	if ( ++p == pe )
+		goto _test_eof164;
+case 164:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 58: goto st157;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st163;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st154;
+	} else
+		goto st154;
+	goto st0;
+st165:
+	if ( ++p == pe )
+		goto _test_eof165;
+case 165:
+	switch( (*p) ) {
+		case 58: goto st157;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st154;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st154;
+	} else
+		goto st154;
+	goto st0;
+st166:
+	if ( ++p == pe )
+		goto _test_eof166;
+case 166:
+	switch( (*p) ) {
+		case 48: goto st167;
+		case 49: goto st172;
+		case 50: goto st175;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 51 <= (*p) && (*p) <= 57 )
+			goto st178;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st179;
+	} else
+		goto st179;
+	goto st0;
+st167:
+	if ( ++p == pe )
+		goto _test_eof167;
+case 167:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 58: goto st171;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st168;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st168;
+	} else
+		goto st168;
+	goto st0;
+st168:
+	if ( ++p == pe )
+		goto _test_eof168;
+case 168:
+	switch( (*p) ) {
+		case 58: goto st171;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st169;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st169;
+	} else
+		goto st169;
+	goto st0;
+st169:
+	if ( ++p == pe )
+		goto _test_eof169;
+case 169:
+	switch( (*p) ) {
+		case 58: goto st171;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st170;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st170;
+	} else
+		goto st170;
+	goto st0;
+st170:
+	if ( ++p == pe )
+		goto _test_eof170;
+case 170:
+	switch( (*p) ) {
+		case 58: goto st171;
+		case 93: goto tr180;
+	}
+	goto st0;
+st171:
+	if ( ++p == pe )
+		goto _test_eof171;
+case 171:
+	switch( (*p) ) {
+		case 48: goto st153;
+		case 49: goto st158;
+		case 50: goto st161;
+	}
+	if ( (*p) < 65 ) {
+		if ( 51 <= (*p) && (*p) <= 57 )
+			goto st164;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st165;
+	} else
+		goto st165;
+	goto st0;
+st172:
+	if ( ++p == pe )
+		goto _test_eof172;
+case 172:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 58: goto st171;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st173;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st168;
+	} else
+		goto st168;
+	goto st0;
+st173:
+	if ( ++p == pe )
+		goto _test_eof173;
+case 173:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 58: goto st171;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st174;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st169;
+	} else
+		goto st169;
+	goto st0;
+st174:
+	if ( ++p == pe )
+		goto _test_eof174;
+case 174:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 58: goto st171;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st170;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st170;
+	} else
+		goto st170;
+	goto st0;
+st175:
+	if ( ++p == pe )
+		goto _test_eof175;
+case 175:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 53: goto st176;
+		case 58: goto st171;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 54 ) {
+		if ( 48 <= (*p) && (*p) <= 52 )
+			goto st173;
+	} else if ( (*p) > 57 ) {
+		if ( (*p) > 70 ) {
+			if ( 97 <= (*p) && (*p) <= 102 )
+				goto st168;
+		} else if ( (*p) >= 65 )
+			goto st168;
+	} else
+		goto st177;
+	goto st0;
+st176:
+	if ( ++p == pe )
+		goto _test_eof176;
+case 176:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 58: goto st171;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 54 ) {
+		if ( 48 <= (*p) && (*p) <= 53 )
+			goto st174;
+	} else if ( (*p) > 57 ) {
+		if ( (*p) > 70 ) {
+			if ( 97 <= (*p) && (*p) <= 102 )
+				goto st169;
+		} else if ( (*p) >= 65 )
+			goto st169;
+	} else
+		goto st169;
+	goto st0;
+st177:
+	if ( ++p == pe )
+		goto _test_eof177;
+case 177:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 58: goto st171;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st169;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st169;
+	} else
+		goto st169;
+	goto st0;
+st178:
+	if ( ++p == pe )
+		goto _test_eof178;
+case 178:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 58: goto st171;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st177;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st168;
+	} else
+		goto st168;
+	goto st0;
+st179:
+	if ( ++p == pe )
+		goto _test_eof179;
+case 179:
+	switch( (*p) ) {
+		case 58: goto st171;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st168;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st168;
+	} else
+		goto st168;
+	goto st0;
+st180:
+	if ( ++p == pe )
+		goto _test_eof180;
+case 180:
+	switch( (*p) ) {
+		case 48: goto st181;
+		case 49: goto st186;
+		case 50: goto st189;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 51 <= (*p) && (*p) <= 57 )
+			goto st192;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st193;
+	} else
+		goto st193;
+	goto st0;
+st181:
+	if ( ++p == pe )
+		goto _test_eof181;
+case 181:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 58: goto st185;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st182;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st182;
+	} else
+		goto st182;
+	goto st0;
+st182:
+	if ( ++p == pe )
+		goto _test_eof182;
+case 182:
+	switch( (*p) ) {
+		case 58: goto st185;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st183;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st183;
+	} else
+		goto st183;
+	goto st0;
+st183:
+	if ( ++p == pe )
+		goto _test_eof183;
+case 183:
+	switch( (*p) ) {
+		case 58: goto st185;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st184;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st184;
+	} else
+		goto st184;
+	goto st0;
+st184:
+	if ( ++p == pe )
+		goto _test_eof184;
+case 184:
+	switch( (*p) ) {
+		case 58: goto st185;
+		case 93: goto tr180;
+	}
+	goto st0;
+st185:
+	if ( ++p == pe )
+		goto _test_eof185;
+case 185:
+	switch( (*p) ) {
+		case 48: goto st167;
+		case 49: goto st172;
+		case 50: goto st175;
+	}
+	if ( (*p) < 65 ) {
+		if ( 51 <= (*p) && (*p) <= 57 )
+			goto st178;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st179;
+	} else
+		goto st179;
+	goto st0;
+st186:
+	if ( ++p == pe )
+		goto _test_eof186;
+case 186:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 58: goto st185;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st187;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st182;
+	} else
+		goto st182;
+	goto st0;
+st187:
+	if ( ++p == pe )
+		goto _test_eof187;
+case 187:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 58: goto st185;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st188;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st183;
+	} else
+		goto st183;
+	goto st0;
+st188:
+	if ( ++p == pe )
+		goto _test_eof188;
+case 188:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 58: goto st185;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st184;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st184;
+	} else
+		goto st184;
+	goto st0;
+st189:
+	if ( ++p == pe )
+		goto _test_eof189;
+case 189:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 53: goto st190;
+		case 58: goto st185;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 54 ) {
+		if ( 48 <= (*p) && (*p) <= 52 )
+			goto st187;
+	} else if ( (*p) > 57 ) {
+		if ( (*p) > 70 ) {
+			if ( 97 <= (*p) && (*p) <= 102 )
+				goto st182;
+		} else if ( (*p) >= 65 )
+			goto st182;
+	} else
+		goto st191;
+	goto st0;
+st190:
+	if ( ++p == pe )
+		goto _test_eof190;
+case 190:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 58: goto st185;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 54 ) {
+		if ( 48 <= (*p) && (*p) <= 53 )
+			goto st188;
+	} else if ( (*p) > 57 ) {
+		if ( (*p) > 70 ) {
+			if ( 97 <= (*p) && (*p) <= 102 )
+				goto st183;
+		} else if ( (*p) >= 65 )
+			goto st183;
+	} else
+		goto st183;
+	goto st0;
+st191:
+	if ( ++p == pe )
+		goto _test_eof191;
+case 191:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 58: goto st185;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st183;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st183;
+	} else
+		goto st183;
+	goto st0;
+st192:
+	if ( ++p == pe )
+		goto _test_eof192;
+case 192:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 58: goto st185;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st191;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st182;
+	} else
+		goto st182;
+	goto st0;
+st193:
+	if ( ++p == pe )
+		goto _test_eof193;
+case 193:
+	switch( (*p) ) {
+		case 58: goto st185;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st182;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st182;
+	} else
+		goto st182;
+	goto st0;
+st194:
+	if ( ++p == pe )
+		goto _test_eof194;
+case 194:
+	switch( (*p) ) {
+		case 48: goto st195;
+		case 49: goto st200;
+		case 50: goto st203;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 51 <= (*p) && (*p) <= 57 )
+			goto st206;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st207;
+	} else
+		goto st207;
+	goto st0;
+st195:
+	if ( ++p == pe )
+		goto _test_eof195;
+case 195:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 58: goto st199;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st196;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st196;
+	} else
+		goto st196;
+	goto st0;
+st196:
+	if ( ++p == pe )
+		goto _test_eof196;
+case 196:
+	switch( (*p) ) {
+		case 58: goto st199;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st197;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st197;
+	} else
+		goto st197;
+	goto st0;
+st197:
+	if ( ++p == pe )
+		goto _test_eof197;
+case 197:
+	switch( (*p) ) {
+		case 58: goto st199;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st198;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st198;
+	} else
+		goto st198;
+	goto st0;
+st198:
+	if ( ++p == pe )
+		goto _test_eof198;
+case 198:
+	switch( (*p) ) {
+		case 58: goto st199;
+		case 93: goto tr180;
+	}
+	goto st0;
+st199:
+	if ( ++p == pe )
+		goto _test_eof199;
+case 199:
+	switch( (*p) ) {
+		case 48: goto st181;
+		case 49: goto st186;
+		case 50: goto st189;
+	}
+	if ( (*p) < 65 ) {
+		if ( 51 <= (*p) && (*p) <= 57 )
+			goto st192;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st193;
+	} else
+		goto st193;
+	goto st0;
+st200:
+	if ( ++p == pe )
+		goto _test_eof200;
+case 200:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 58: goto st199;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st201;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st196;
+	} else
+		goto st196;
+	goto st0;
+st201:
+	if ( ++p == pe )
+		goto _test_eof201;
+case 201:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 58: goto st199;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st202;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st197;
+	} else
+		goto st197;
+	goto st0;
+st202:
+	if ( ++p == pe )
+		goto _test_eof202;
+case 202:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 58: goto st199;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st198;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st198;
+	} else
+		goto st198;
+	goto st0;
+st203:
+	if ( ++p == pe )
+		goto _test_eof203;
+case 203:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 53: goto st204;
+		case 58: goto st199;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 54 ) {
+		if ( 48 <= (*p) && (*p) <= 52 )
+			goto st201;
+	} else if ( (*p) > 57 ) {
+		if ( (*p) > 70 ) {
+			if ( 97 <= (*p) && (*p) <= 102 )
+				goto st196;
+		} else if ( (*p) >= 65 )
+			goto st196;
+	} else
+		goto st205;
+	goto st0;
+st204:
+	if ( ++p == pe )
+		goto _test_eof204;
+case 204:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 58: goto st199;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 54 ) {
+		if ( 48 <= (*p) && (*p) <= 53 )
+			goto st202;
+	} else if ( (*p) > 57 ) {
+		if ( (*p) > 70 ) {
+			if ( 97 <= (*p) && (*p) <= 102 )
+				goto st197;
+		} else if ( (*p) >= 65 )
+			goto st197;
+	} else
+		goto st197;
+	goto st0;
+st205:
+	if ( ++p == pe )
+		goto _test_eof205;
+case 205:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 58: goto st199;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st197;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st197;
+	} else
+		goto st197;
+	goto st0;
+st206:
+	if ( ++p == pe )
+		goto _test_eof206;
+case 206:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 58: goto st199;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st205;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st196;
+	} else
+		goto st196;
+	goto st0;
+st207:
+	if ( ++p == pe )
+		goto _test_eof207;
+case 207:
+	switch( (*p) ) {
+		case 58: goto st199;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st196;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st196;
+	} else
+		goto st196;
+	goto st0;
+st208:
+	if ( ++p == pe )
+		goto _test_eof208;
+case 208:
+	switch( (*p) ) {
+		case 48: goto st209;
+		case 49: goto st214;
+		case 50: goto st217;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 51 <= (*p) && (*p) <= 57 )
+			goto st220;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st221;
+	} else
+		goto st221;
+	goto st0;
+st209:
+	if ( ++p == pe )
+		goto _test_eof209;
+case 209:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 58: goto st213;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st210;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st210;
+	} else
+		goto st210;
+	goto st0;
+st210:
+	if ( ++p == pe )
+		goto _test_eof210;
+case 210:
+	switch( (*p) ) {
+		case 58: goto st213;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st211;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st211;
+	} else
+		goto st211;
+	goto st0;
+st211:
+	if ( ++p == pe )
+		goto _test_eof211;
+case 211:
+	switch( (*p) ) {
+		case 58: goto st213;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st212;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st212;
+	} else
+		goto st212;
+	goto st0;
+st212:
+	if ( ++p == pe )
+		goto _test_eof212;
+case 212:
+	switch( (*p) ) {
+		case 58: goto st213;
+		case 93: goto tr180;
+	}
+	goto st0;
+st213:
+	if ( ++p == pe )
+		goto _test_eof213;
+case 213:
+	switch( (*p) ) {
+		case 48: goto st195;
+		case 49: goto st200;
+		case 50: goto st203;
+	}
+	if ( (*p) < 65 ) {
+		if ( 51 <= (*p) && (*p) <= 57 )
+			goto st206;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st207;
+	} else
+		goto st207;
+	goto st0;
+st214:
+	if ( ++p == pe )
+		goto _test_eof214;
+case 214:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 58: goto st213;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st215;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st210;
+	} else
+		goto st210;
+	goto st0;
+st215:
+	if ( ++p == pe )
+		goto _test_eof215;
+case 215:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 58: goto st213;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st216;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st211;
+	} else
+		goto st211;
+	goto st0;
+st216:
+	if ( ++p == pe )
+		goto _test_eof216;
+case 216:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 58: goto st213;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st212;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st212;
+	} else
+		goto st212;
+	goto st0;
+st217:
+	if ( ++p == pe )
+		goto _test_eof217;
+case 217:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 53: goto st218;
+		case 58: goto st213;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 54 ) {
+		if ( 48 <= (*p) && (*p) <= 52 )
+			goto st215;
+	} else if ( (*p) > 57 ) {
+		if ( (*p) > 70 ) {
+			if ( 97 <= (*p) && (*p) <= 102 )
+				goto st210;
+		} else if ( (*p) >= 65 )
+			goto st210;
+	} else
+		goto st219;
+	goto st0;
+st218:
+	if ( ++p == pe )
+		goto _test_eof218;
+case 218:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 58: goto st213;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 54 ) {
+		if ( 48 <= (*p) && (*p) <= 53 )
+			goto st216;
+	} else if ( (*p) > 57 ) {
+		if ( (*p) > 70 ) {
+			if ( 97 <= (*p) && (*p) <= 102 )
+				goto st211;
+		} else if ( (*p) >= 65 )
+			goto st211;
+	} else
+		goto st211;
+	goto st0;
+st219:
+	if ( ++p == pe )
+		goto _test_eof219;
+case 219:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 58: goto st213;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st211;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st211;
+	} else
+		goto st211;
+	goto st0;
+st220:
+	if ( ++p == pe )
+		goto _test_eof220;
+case 220:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 58: goto st213;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st219;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st210;
+	} else
+		goto st210;
+	goto st0;
+st221:
+	if ( ++p == pe )
+		goto _test_eof221;
+case 221:
+	switch( (*p) ) {
+		case 58: goto st213;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st210;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st210;
+	} else
+		goto st210;
+	goto st0;
+st222:
+	if ( ++p == pe )
+		goto _test_eof222;
+case 222:
+	if ( (*p) == 58 )
+		goto st223;
+	goto st0;
+st223:
+	if ( ++p == pe )
+		goto _test_eof223;
+case 223:
+	switch( (*p) ) {
+		case 48: goto st224;
+		case 49: goto st229;
+		case 50: goto st232;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 51 <= (*p) && (*p) <= 57 )
+			goto st235;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st236;
+	} else
+		goto st236;
+	goto st0;
+st224:
+	if ( ++p == pe )
+		goto _test_eof224;
+case 224:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 58: goto st228;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st225;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st225;
+	} else
+		goto st225;
+	goto st0;
+st225:
+	if ( ++p == pe )
+		goto _test_eof225;
+case 225:
+	switch( (*p) ) {
+		case 58: goto st228;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st226;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st226;
+	} else
+		goto st226;
+	goto st0;
+st226:
+	if ( ++p == pe )
+		goto _test_eof226;
+case 226:
+	switch( (*p) ) {
+		case 58: goto st228;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st227;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st227;
+	} else
+		goto st227;
+	goto st0;
+st227:
+	if ( ++p == pe )
+		goto _test_eof227;
+case 227:
+	switch( (*p) ) {
+		case 58: goto st228;
+		case 93: goto tr180;
+	}
+	goto st0;
+st228:
+	if ( ++p == pe )
+		goto _test_eof228;
+case 228:
+	switch( (*p) ) {
+		case 48: goto st209;
+		case 49: goto st214;
+		case 50: goto st217;
+	}
+	if ( (*p) < 65 ) {
+		if ( 51 <= (*p) && (*p) <= 57 )
+			goto st220;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st221;
+	} else
+		goto st221;
+	goto st0;
+st229:
+	if ( ++p == pe )
+		goto _test_eof229;
+case 229:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 58: goto st228;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st230;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st225;
+	} else
+		goto st225;
+	goto st0;
+st230:
+	if ( ++p == pe )
+		goto _test_eof230;
+case 230:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 58: goto st228;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st231;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st226;
+	} else
+		goto st226;
+	goto st0;
+st231:
+	if ( ++p == pe )
+		goto _test_eof231;
+case 231:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 58: goto st228;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st227;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st227;
+	} else
+		goto st227;
+	goto st0;
+st232:
+	if ( ++p == pe )
+		goto _test_eof232;
+case 232:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 53: goto st233;
+		case 58: goto st228;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 54 ) {
+		if ( 48 <= (*p) && (*p) <= 52 )
+			goto st230;
+	} else if ( (*p) > 57 ) {
+		if ( (*p) > 70 ) {
+			if ( 97 <= (*p) && (*p) <= 102 )
+				goto st225;
+		} else if ( (*p) >= 65 )
+			goto st225;
+	} else
+		goto st234;
+	goto st0;
+st233:
+	if ( ++p == pe )
+		goto _test_eof233;
+case 233:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 58: goto st228;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 54 ) {
+		if ( 48 <= (*p) && (*p) <= 53 )
+			goto st231;
+	} else if ( (*p) > 57 ) {
+		if ( (*p) > 70 ) {
+			if ( 97 <= (*p) && (*p) <= 102 )
+				goto st226;
+		} else if ( (*p) >= 65 )
+			goto st226;
+	} else
+		goto st226;
+	goto st0;
+st234:
+	if ( ++p == pe )
+		goto _test_eof234;
+case 234:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 58: goto st228;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st226;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st226;
+	} else
+		goto st226;
+	goto st0;
+st235:
+	if ( ++p == pe )
+		goto _test_eof235;
+case 235:
+	switch( (*p) ) {
+		case 46: goto st118;
+		case 58: goto st228;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st234;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st225;
+	} else
+		goto st225;
+	goto st0;
+st236:
+	if ( ++p == pe )
+		goto _test_eof236;
+case 236:
+	switch( (*p) ) {
+		case 58: goto st228;
+		case 93: goto tr180;
+	}
+	if ( (*p) < 65 ) {
+		if ( 48 <= (*p) && (*p) <= 57 )
+			goto st225;
+	} else if ( (*p) > 70 ) {
+		if ( 97 <= (*p) && (*p) <= 102 )
+			goto st225;
+	} else
+		goto st225;
+	goto st0;
+	}
+	_test_eof2: cs = 2; goto _test_eof; 
+	_test_eof3: cs = 3; goto _test_eof; 
+	_test_eof4: cs = 4; goto _test_eof; 
+	_test_eof5: cs = 5; goto _test_eof; 
+	_test_eof6: cs = 6; goto _test_eof; 
+	_test_eof7: cs = 7; goto _test_eof; 
+	_test_eof237: cs = 237; goto _test_eof; 
+	_test_eof238: cs = 238; goto _test_eof; 
+	_test_eof239: cs = 239; goto _test_eof; 
+	_test_eof240: cs = 240; goto _test_eof; 
+	_test_eof241: cs = 241; goto _test_eof; 
+	_test_eof8: cs = 8; goto _test_eof; 
+	_test_eof9: cs = 9; goto _test_eof; 
+	_test_eof10: cs = 10; goto _test_eof; 
+	_test_eof11: cs = 11; goto _test_eof; 
+	_test_eof12: cs = 12; goto _test_eof; 
+	_test_eof13: cs = 13; goto _test_eof; 
+	_test_eof14: cs = 14; goto _test_eof; 
+	_test_eof15: cs = 15; goto _test_eof; 
+	_test_eof16: cs = 16; goto _test_eof; 
+	_test_eof17: cs = 17; goto _test_eof; 
+	_test_eof18: cs = 18; goto _test_eof; 
+	_test_eof19: cs = 19; goto _test_eof; 
+	_test_eof20: cs = 20; goto _test_eof; 
+	_test_eof21: cs = 21; goto _test_eof; 
+	_test_eof22: cs = 22; goto _test_eof; 
+	_test_eof23: cs = 23; goto _test_eof; 
+	_test_eof24: cs = 24; goto _test_eof; 
+	_test_eof25: cs = 25; goto _test_eof; 
+	_test_eof26: cs = 26; goto _test_eof; 
+	_test_eof27: cs = 27; goto _test_eof; 
+	_test_eof28: cs = 28; goto _test_eof; 
+	_test_eof29: cs = 29; goto _test_eof; 
+	_test_eof30: cs = 30; goto _test_eof; 
+	_test_eof31: cs = 31; goto _test_eof; 
+	_test_eof32: cs = 32; goto _test_eof; 
+	_test_eof33: cs = 33; goto _test_eof; 
+	_test_eof34: cs = 34; goto _test_eof; 
+	_test_eof35: cs = 35; goto _test_eof; 
+	_test_eof36: cs = 36; goto _test_eof; 
+	_test_eof37: cs = 37; goto _test_eof; 
+	_test_eof38: cs = 38; goto _test_eof; 
+	_test_eof39: cs = 39; goto _test_eof; 
+	_test_eof40: cs = 40; goto _test_eof; 
+	_test_eof41: cs = 41; goto _test_eof; 
+	_test_eof42: cs = 42; goto _test_eof; 
+	_test_eof43: cs = 43; goto _test_eof; 
+	_test_eof44: cs = 44; goto _test_eof; 
+	_test_eof45: cs = 45; goto _test_eof; 
+	_test_eof46: cs = 46; goto _test_eof; 
+	_test_eof47: cs = 47; goto _test_eof; 
+	_test_eof48: cs = 48; goto _test_eof; 
+	_test_eof49: cs = 49; goto _test_eof; 
+	_test_eof50: cs = 50; goto _test_eof; 
+	_test_eof242: cs = 242; goto _test_eof; 
+	_test_eof243: cs = 243; goto _test_eof; 
+	_test_eof244: cs = 244; goto _test_eof; 
+	_test_eof245: cs = 245; goto _test_eof; 
+	_test_eof51: cs = 51; goto _test_eof; 
+	_test_eof52: cs = 52; goto _test_eof; 
+	_test_eof53: cs = 53; goto _test_eof; 
+	_test_eof54: cs = 54; goto _test_eof; 
+	_test_eof55: cs = 55; goto _test_eof; 
+	_test_eof56: cs = 56; goto _test_eof; 
+	_test_eof57: cs = 57; goto _test_eof; 
+	_test_eof58: cs = 58; goto _test_eof; 
+	_test_eof59: cs = 59; goto _test_eof; 
+	_test_eof60: cs = 60; goto _test_eof; 
+	_test_eof61: cs = 61; goto _test_eof; 
+	_test_eof62: cs = 62; goto _test_eof; 
+	_test_eof246: cs = 246; goto _test_eof; 
+	_test_eof247: cs = 247; goto _test_eof; 
+	_test_eof248: cs = 248; goto _test_eof; 
+	_test_eof63: cs = 63; goto _test_eof; 
+	_test_eof64: cs = 64; goto _test_eof; 
+	_test_eof65: cs = 65; goto _test_eof; 
+	_test_eof66: cs = 66; goto _test_eof; 
+	_test_eof67: cs = 67; goto _test_eof; 
+	_test_eof68: cs = 68; goto _test_eof; 
+	_test_eof69: cs = 69; goto _test_eof; 
+	_test_eof249: cs = 249; goto _test_eof; 
+	_test_eof70: cs = 70; goto _test_eof; 
+	_test_eof250: cs = 250; goto _test_eof; 
+	_test_eof251: cs = 251; goto _test_eof; 
+	_test_eof252: cs = 252; goto _test_eof; 
+	_test_eof253: cs = 253; goto _test_eof; 
+	_test_eof254: cs = 254; goto _test_eof; 
+	_test_eof71: cs = 71; goto _test_eof; 
+	_test_eof255: cs = 255; goto _test_eof; 
+	_test_eof256: cs = 256; goto _test_eof; 
+	_test_eof257: cs = 257; goto _test_eof; 
+	_test_eof258: cs = 258; goto _test_eof; 
+	_test_eof259: cs = 259; goto _test_eof; 
+	_test_eof260: cs = 260; goto _test_eof; 
+	_test_eof261: cs = 261; goto _test_eof; 
+	_test_eof262: cs = 262; goto _test_eof; 
+	_test_eof263: cs = 263; goto _test_eof; 
+	_test_eof264: cs = 264; goto _test_eof; 
+	_test_eof265: cs = 265; goto _test_eof; 
+	_test_eof266: cs = 266; goto _test_eof; 
+	_test_eof267: cs = 267; goto _test_eof; 
+	_test_eof72: cs = 72; goto _test_eof; 
+	_test_eof268: cs = 268; goto _test_eof; 
+	_test_eof269: cs = 269; goto _test_eof; 
+	_test_eof270: cs = 270; goto _test_eof; 
+	_test_eof271: cs = 271; goto _test_eof; 
+	_test_eof272: cs = 272; goto _test_eof; 
+	_test_eof273: cs = 273; goto _test_eof; 
+	_test_eof274: cs = 274; goto _test_eof; 
+	_test_eof275: cs = 275; goto _test_eof; 
+	_test_eof276: cs = 276; goto _test_eof; 
+	_test_eof277: cs = 277; goto _test_eof; 
+	_test_eof278: cs = 278; goto _test_eof; 
+	_test_eof279: cs = 279; goto _test_eof; 
+	_test_eof280: cs = 280; goto _test_eof; 
+	_test_eof73: cs = 73; goto _test_eof; 
+	_test_eof281: cs = 281; goto _test_eof; 
+	_test_eof282: cs = 282; goto _test_eof; 
+	_test_eof283: cs = 283; goto _test_eof; 
+	_test_eof284: cs = 284; goto _test_eof; 
+	_test_eof285: cs = 285; goto _test_eof; 
+	_test_eof286: cs = 286; goto _test_eof; 
+	_test_eof287: cs = 287; goto _test_eof; 
+	_test_eof288: cs = 288; goto _test_eof; 
+	_test_eof289: cs = 289; goto _test_eof; 
+	_test_eof290: cs = 290; goto _test_eof; 
+	_test_eof291: cs = 291; goto _test_eof; 
+	_test_eof292: cs = 292; goto _test_eof; 
+	_test_eof293: cs = 293; goto _test_eof; 
+	_test_eof74: cs = 74; goto _test_eof; 
+	_test_eof294: cs = 294; goto _test_eof; 
+	_test_eof295: cs = 295; goto _test_eof; 
+	_test_eof296: cs = 296; goto _test_eof; 
+	_test_eof297: cs = 297; goto _test_eof; 
+	_test_eof298: cs = 298; goto _test_eof; 
+	_test_eof299: cs = 299; goto _test_eof; 
+	_test_eof300: cs = 300; goto _test_eof; 
+	_test_eof301: cs = 301; goto _test_eof; 
+	_test_eof302: cs = 302; goto _test_eof; 
+	_test_eof303: cs = 303; goto _test_eof; 
+	_test_eof304: cs = 304; goto _test_eof; 
+	_test_eof305: cs = 305; goto _test_eof; 
+	_test_eof306: cs = 306; goto _test_eof; 
+	_test_eof75: cs = 75; goto _test_eof; 
+	_test_eof307: cs = 307; goto _test_eof; 
+	_test_eof308: cs = 308; goto _test_eof; 
+	_test_eof309: cs = 309; goto _test_eof; 
+	_test_eof310: cs = 310; goto _test_eof; 
+	_test_eof311: cs = 311; goto _test_eof; 
+	_test_eof312: cs = 312; goto _test_eof; 
+	_test_eof313: cs = 313; goto _test_eof; 
+	_test_eof314: cs = 314; goto _test_eof; 
+	_test_eof76: cs = 76; goto _test_eof; 
+	_test_eof77: cs = 77; goto _test_eof; 
+	_test_eof78: cs = 78; goto _test_eof; 
+	_test_eof79: cs = 79; goto _test_eof; 
+	_test_eof80: cs = 80; goto _test_eof; 
+	_test_eof81: cs = 81; goto _test_eof; 
+	_test_eof82: cs = 82; goto _test_eof; 
+	_test_eof83: cs = 83; goto _test_eof; 
+	_test_eof315: cs = 315; goto _test_eof; 
+	_test_eof316: cs = 316; goto _test_eof; 
+	_test_eof317: cs = 317; goto _test_eof; 
+	_test_eof318: cs = 318; goto _test_eof; 
+	_test_eof319: cs = 319; goto _test_eof; 
+	_test_eof84: cs = 84; goto _test_eof; 
+	_test_eof320: cs = 320; goto _test_eof; 
+	_test_eof321: cs = 321; goto _test_eof; 
+	_test_eof322: cs = 322; goto _test_eof; 
+	_test_eof323: cs = 323; goto _test_eof; 
+	_test_eof324: cs = 324; goto _test_eof; 
+	_test_eof325: cs = 325; goto _test_eof; 
+	_test_eof326: cs = 326; goto _test_eof; 
+	_test_eof327: cs = 327; goto _test_eof; 
+	_test_eof85: cs = 85; goto _test_eof; 
+	_test_eof86: cs = 86; goto _test_eof; 
+	_test_eof87: cs = 87; goto _test_eof; 
+	_test_eof88: cs = 88; goto _test_eof; 
+	_test_eof89: cs = 89; goto _test_eof; 
+	_test_eof90: cs = 90; goto _test_eof; 
+	_test_eof91: cs = 91; goto _test_eof; 
+	_test_eof92: cs = 92; goto _test_eof; 
+	_test_eof93: cs = 93; goto _test_eof; 
+	_test_eof94: cs = 94; goto _test_eof; 
+	_test_eof95: cs = 95; goto _test_eof; 
+	_test_eof96: cs = 96; goto _test_eof; 
+	_test_eof97: cs = 97; goto _test_eof; 
+	_test_eof98: cs = 98; goto _test_eof; 
+	_test_eof99: cs = 99; goto _test_eof; 
+	_test_eof100: cs = 100; goto _test_eof; 
+	_test_eof101: cs = 101; goto _test_eof; 
+	_test_eof102: cs = 102; goto _test_eof; 
+	_test_eof103: cs = 103; goto _test_eof; 
+	_test_eof104: cs = 104; goto _test_eof; 
+	_test_eof105: cs = 105; goto _test_eof; 
+	_test_eof106: cs = 106; goto _test_eof; 
+	_test_eof107: cs = 107; goto _test_eof; 
+	_test_eof108: cs = 108; goto _test_eof; 
+	_test_eof109: cs = 109; goto _test_eof; 
+	_test_eof110: cs = 110; goto _test_eof; 
+	_test_eof111: cs = 111; goto _test_eof; 
+	_test_eof112: cs = 112; goto _test_eof; 
+	_test_eof113: cs = 113; goto _test_eof; 
+	_test_eof114: cs = 114; goto _test_eof; 
+	_test_eof115: cs = 115; goto _test_eof; 
+	_test_eof116: cs = 116; goto _test_eof; 
+	_test_eof117: cs = 117; goto _test_eof; 
+	_test_eof118: cs = 118; goto _test_eof; 
+	_test_eof119: cs = 119; goto _test_eof; 
+	_test_eof120: cs = 120; goto _test_eof; 
+	_test_eof121: cs = 121; goto _test_eof; 
+	_test_eof122: cs = 122; goto _test_eof; 
+	_test_eof123: cs = 123; goto _test_eof; 
+	_test_eof124: cs = 124; goto _test_eof; 
+	_test_eof125: cs = 125; goto _test_eof; 
+	_test_eof126: cs = 126; goto _test_eof; 
+	_test_eof127: cs = 127; goto _test_eof; 
+	_test_eof128: cs = 128; goto _test_eof; 
+	_test_eof129: cs = 129; goto _test_eof; 
+	_test_eof130: cs = 130; goto _test_eof; 
+	_test_eof131: cs = 131; goto _test_eof; 
+	_test_eof132: cs = 132; goto _test_eof; 
+	_test_eof133: cs = 133; goto _test_eof; 
+	_test_eof134: cs = 134; goto _test_eof; 
+	_test_eof135: cs = 135; goto _test_eof; 
+	_test_eof136: cs = 136; goto _test_eof; 
+	_test_eof137: cs = 137; goto _test_eof; 
+	_test_eof138: cs = 138; goto _test_eof; 
+	_test_eof139: cs = 139; goto _test_eof; 
+	_test_eof140: cs = 140; goto _test_eof; 
+	_test_eof141: cs = 141; goto _test_eof; 
+	_test_eof142: cs = 142; goto _test_eof; 
+	_test_eof143: cs = 143; goto _test_eof; 
+	_test_eof144: cs = 144; goto _test_eof; 
+	_test_eof145: cs = 145; goto _test_eof; 
+	_test_eof146: cs = 146; goto _test_eof; 
+	_test_eof147: cs = 147; goto _test_eof; 
+	_test_eof148: cs = 148; goto _test_eof; 
+	_test_eof149: cs = 149; goto _test_eof; 
+	_test_eof150: cs = 150; goto _test_eof; 
+	_test_eof151: cs = 151; goto _test_eof; 
+	_test_eof152: cs = 152; goto _test_eof; 
+	_test_eof153: cs = 153; goto _test_eof; 
+	_test_eof154: cs = 154; goto _test_eof; 
+	_test_eof155: cs = 155; goto _test_eof; 
+	_test_eof156: cs = 156; goto _test_eof; 
+	_test_eof157: cs = 157; goto _test_eof; 
+	_test_eof158: cs = 158; goto _test_eof; 
+	_test_eof159: cs = 159; goto _test_eof; 
+	_test_eof160: cs = 160; goto _test_eof; 
+	_test_eof161: cs = 161; goto _test_eof; 
+	_test_eof162: cs = 162; goto _test_eof; 
+	_test_eof163: cs = 163; goto _test_eof; 
+	_test_eof164: cs = 164; goto _test_eof; 
+	_test_eof165: cs = 165; goto _test_eof; 
+	_test_eof166: cs = 166; goto _test_eof; 
+	_test_eof167: cs = 167; goto _test_eof; 
+	_test_eof168: cs = 168; goto _test_eof; 
+	_test_eof169: cs = 169; goto _test_eof; 
+	_test_eof170: cs = 170; goto _test_eof; 
+	_test_eof171: cs = 171; goto _test_eof; 
+	_test_eof172: cs = 172; goto _test_eof; 
+	_test_eof173: cs = 173; goto _test_eof; 
+	_test_eof174: cs = 174; goto _test_eof; 
+	_test_eof175: cs = 175; goto _test_eof; 
+	_test_eof176: cs = 176; goto _test_eof; 
+	_test_eof177: cs = 177; goto _test_eof; 
+	_test_eof178: cs = 178; goto _test_eof; 
+	_test_eof179: cs = 179; goto _test_eof; 
+	_test_eof180: cs = 180; goto _test_eof; 
+	_test_eof181: cs = 181; goto _test_eof; 
+	_test_eof182: cs = 182; goto _test_eof; 
+	_test_eof183: cs = 183; goto _test_eof; 
+	_test_eof184: cs = 184; goto _test_eof; 
+	_test_eof185: cs = 185; goto _test_eof; 
+	_test_eof186: cs = 186; goto _test_eof; 
+	_test_eof187: cs = 187; goto _test_eof; 
+	_test_eof188: cs = 188; goto _test_eof; 
+	_test_eof189: cs = 189; goto _test_eof; 
+	_test_eof190: cs = 190; goto _test_eof; 
+	_test_eof191: cs = 191; goto _test_eof; 
+	_test_eof192: cs = 192; goto _test_eof; 
+	_test_eof193: cs = 193; goto _test_eof; 
+	_test_eof194: cs = 194; goto _test_eof; 
+	_test_eof195: cs = 195; goto _test_eof; 
+	_test_eof196: cs = 196; goto _test_eof; 
+	_test_eof197: cs = 197; goto _test_eof; 
+	_test_eof198: cs = 198; goto _test_eof; 
+	_test_eof199: cs = 199; goto _test_eof; 
+	_test_eof200: cs = 200; goto _test_eof; 
+	_test_eof201: cs = 201; goto _test_eof; 
+	_test_eof202: cs = 202; goto _test_eof; 
+	_test_eof203: cs = 203; goto _test_eof; 
+	_test_eof204: cs = 204; goto _test_eof; 
+	_test_eof205: cs = 205; goto _test_eof; 
+	_test_eof206: cs = 206; goto _test_eof; 
+	_test_eof207: cs = 207; goto _test_eof; 
+	_test_eof208: cs = 208; goto _test_eof; 
+	_test_eof209: cs = 209; goto _test_eof; 
+	_test_eof210: cs = 210; goto _test_eof; 
+	_test_eof211: cs = 211; goto _test_eof; 
+	_test_eof212: cs = 212; goto _test_eof; 
+	_test_eof213: cs = 213; goto _test_eof; 
+	_test_eof214: cs = 214; goto _test_eof; 
+	_test_eof215: cs = 215; goto _test_eof; 
+	_test_eof216: cs = 216; goto _test_eof; 
+	_test_eof217: cs = 217; goto _test_eof; 
+	_test_eof218: cs = 218; goto _test_eof; 
+	_test_eof219: cs = 219; goto _test_eof; 
+	_test_eof220: cs = 220; goto _test_eof; 
+	_test_eof221: cs = 221; goto _test_eof; 
+	_test_eof222: cs = 222; goto _test_eof; 
+	_test_eof223: cs = 223; goto _test_eof; 
+	_test_eof224: cs = 224; goto _test_eof; 
+	_test_eof225: cs = 225; goto _test_eof; 
+	_test_eof226: cs = 226; goto _test_eof; 
+	_test_eof227: cs = 227; goto _test_eof; 
+	_test_eof228: cs = 228; goto _test_eof; 
+	_test_eof229: cs = 229; goto _test_eof; 
+	_test_eof230: cs = 230; goto _test_eof; 
+	_test_eof231: cs = 231; goto _test_eof; 
+	_test_eof232: cs = 232; goto _test_eof; 
+	_test_eof233: cs = 233; goto _test_eof; 
+	_test_eof234: cs = 234; goto _test_eof; 
+	_test_eof235: cs = 235; goto _test_eof; 
+	_test_eof236: cs = 236; goto _test_eof; 
+
+	_test_eof: {}
+	_out: {}
+	}
+
+#line 59 "ip_parser.rl"
+
+  if(len != p-str)
+    return ip_type_error;
+  else
+    return ip_type;
+}
+
diff --git a/modules/ipops/ip_parser.h b/modules/ipops/ip_parser.h
new file mode 100644
index 0000000..23ca248
--- /dev/null
+++ b/modules/ipops/ip_parser.h
@@ -0,0 +1,24 @@
+/*
+ * Warning: This file is auto generated from a ragel syntax (ip_parser.rl),
+ * do not change it!
+ */   
+
+#ifndef ip_parser_h
+#define ip_parser_h
+
+
+#include <sys/types.h>
+
+
+enum enum_ip_type {
+  ip_type_ipv4 = 1,
+  ip_type_ipv6,
+  ip_type_ipv6_reference,
+  ip_type_error
+};
+
+
+enum enum_ip_type ip_parser_execute(const char *str, size_t len);
+
+
+#endif
diff --git a/modules/ipops/ip_parser.rl b/modules/ipops/ip_parser.rl
new file mode 100644
index 0000000..4b6ce16
--- /dev/null
+++ b/modules/ipops/ip_parser.rl
@@ -0,0 +1,65 @@
+#include "ip_parser.h"
+
+
+/** Ragel machine **/
+%%{
+  machine ip_parser;
+
+  action is_ipv4 {
+    ip_type = ip_type_ipv4;
+  }
+
+  action is_ipv6 {
+    ip_type = ip_type_ipv6;
+  }
+
+  action is_ipv6_reference {
+    ip_type = ip_type_ipv6_reference;
+  }
+
+  DIGIT                = "0".."9";
+  HEXDIG               = DIGIT | "A"i | "B"i | "C"i | "D"i | "E"i | "F"i;
+  dec_octet            = DIGIT | ( 0x31..0x39 DIGIT ) | ( "1" DIGIT{2} ) |
+                         ( "2" 0x30..0x34 DIGIT ) | ( "25" 0x30..0x35 );
+  IPv4address          = dec_octet "." dec_octet "." dec_octet "." dec_octet;
+  h16                  = HEXDIG{1,4};
+  ls32                 = ( h16 ":" h16 ) | IPv4address;
+  IPv6address          = ( ( h16 ":" ){6} ls32 ) |
+                         ( "::" ( h16 ":" ){5} ls32 ) |
+                         ( h16? "::" ( h16 ":" ){4} ls32 ) |
+                         ( ( ( h16 ":" )? h16 )? "::" ( h16 ":" ){3} ls32 ) |
+                         ( ( ( h16 ":" ){,2} h16 )? "::" ( h16 ":" ){2} ls32 ) |
+                         ( ( ( h16 ":" ){,3} h16 )? "::" h16 ":" ls32 ) |
+                         ( ( ( h16 ":" ){,4} h16 )? "::" ls32 ) |
+                         ( ( ( h16 ":" ){,5} h16 )? "::" h16 ) |
+                         ( ( ( h16 ":" ){,6} h16 )? "::" );
+  IPv6reference        = "[" IPv6address "]";
+
+  main                := IPv4address @is_ipv4 |
+                         IPv6address @is_ipv6 |
+                         IPv6reference @is_ipv6_reference;
+}%%
+
+/** Data **/
+%% write data;
+
+
+/** exec **/
+enum enum_ip_type ip_parser_execute(const char *str, size_t len)
+{
+  int cs = 0;
+  const char *p, *pe;
+  enum enum_ip_type ip_type = ip_type_error;
+
+  p = str;
+  pe = str+len;
+
+  %% write init;
+  %% write exec;
+
+  if(len != p-str)
+    return ip_type_error;
+  else
+    return ip_type;
+}
+
diff --git a/modules/ipops/ipops_mod.c b/modules/ipops/ipops_mod.c
new file mode 100644
index 0000000..df51144
--- /dev/null
+++ b/modules/ipops/ipops_mod.c
@@ -0,0 +1,593 @@
+/*
+ * ipops module - IPv4 and Ipv6 operations
+ *
+ * Copyright (C) 2011 Iñaki Baz Castillo
+ *
+ * This file is part of SIP Router, a free SIP server.
+ *
+ * SIP Router is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ * SIP Router is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * History:
+ * -------
+ *  2011-07-29: Added a function to detect RFC1918 private IPv4 addresses (ibc)
+ *  2011-04-27: Initial version (ibc)
+ */
+/*!
+ * \file
+ * \brief SIP-router ipops :: Module interface
+ * \ingroup ipops
+ * Copyright (C) 2011 Iñaki Baz Castillo
+ * Module: \ref ipops
+ */
+
+/*! \defgroup ipops SIP-router ipops Module
+ *
+ * The ipops module provide IPv4 and IPv6 operations.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <arpa/inet.h>
+#include "../../sr_module.h"
+#include "../../dprint.h"
+#include "../../str.h"
+#include "../../mod_fix.h"
+#include "../../pvar.h"
+#include "ip_parser.h"
+#include "rfc1918_parser.h"
+
+
+
+/*
+ * Module parameter variables
+ */
+
+
+/*
+ * Module core functions
+ */
+
+
+/*
+ * Module internal functions
+ */
+static int _compare_ips(char*, size_t, enum enum_ip_type, char*, size_t, enum enum_ip_type);
+int _ip_is_in_subnet(char *ip1, size_t len1, enum enum_ip_type ip1_type, char *ip2, size_t len2, enum enum_ip_type ip2_type, int netmask);
+
+
+/*
+ * Script functions
+ */
+static int w_is_ip(struct sip_msg*, char*);
+static int w_is_pure_ip(struct sip_msg*, char*);
+static int w_is_ipv4(struct sip_msg*, char*);
+static int w_is_ipv6(struct sip_msg*, char*);
+static int w_is_ipv6_reference(struct sip_msg*, char*);
+static int w_ip_type(struct sip_msg*, char*);
+static int w_compare_ips(struct sip_msg*, char*, char*);
+static int w_compare_pure_ips(struct sip_msg*, char*, char*);
+static int w_is_ip_rfc1918(struct sip_msg*, char*);
+static int w_ip_is_in_subnet(struct sip_msg*, char*, char*);
+
+
+/*
+ * Exported functions
+ */
+static cmd_export_t cmds[] =
+{
+  { "is_ip", (cmd_function)w_is_ip, 1, fixup_spve_null, 0,
+  REQUEST_ROUTE|FAILURE_ROUTE|ONREPLY_ROUTE|BRANCH_ROUTE|LOCAL_ROUTE },
+  { "is_pure_ip", (cmd_function)w_is_pure_ip, 1, fixup_spve_null, 0,
+  REQUEST_ROUTE|FAILURE_ROUTE|ONREPLY_ROUTE|BRANCH_ROUTE|LOCAL_ROUTE },
+  { "is_ipv4", (cmd_function)w_is_ipv4, 1, fixup_spve_null, 0,
+  REQUEST_ROUTE|FAILURE_ROUTE|ONREPLY_ROUTE|BRANCH_ROUTE|LOCAL_ROUTE },
+  { "is_ipv6", (cmd_function)w_is_ipv6, 1, fixup_spve_null, 0,
+  REQUEST_ROUTE|FAILURE_ROUTE|ONREPLY_ROUTE|BRANCH_ROUTE|LOCAL_ROUTE },
+  { "is_ipv6_reference", (cmd_function)w_is_ipv6_reference, 1, fixup_spve_null, 0,
+  REQUEST_ROUTE|FAILURE_ROUTE|ONREPLY_ROUTE|BRANCH_ROUTE|LOCAL_ROUTE },
+  { "ip_type", (cmd_function)w_ip_type, 1, fixup_spve_null, 0,
+  REQUEST_ROUTE|FAILURE_ROUTE|ONREPLY_ROUTE|BRANCH_ROUTE|LOCAL_ROUTE },
+  { "compare_ips", (cmd_function)w_compare_ips, 2, fixup_spve_spve, 0,
+  REQUEST_ROUTE|FAILURE_ROUTE|ONREPLY_ROUTE|BRANCH_ROUTE|LOCAL_ROUTE },
+  { "compare_pure_ips", (cmd_function)w_compare_pure_ips, 2, fixup_spve_spve, 0,
+  REQUEST_ROUTE|FAILURE_ROUTE|ONREPLY_ROUTE|BRANCH_ROUTE|LOCAL_ROUTE },
+  { "is_ip_rfc1918", (cmd_function)w_is_ip_rfc1918, 1, fixup_spve_null, 0,
+  REQUEST_ROUTE|FAILURE_ROUTE|ONREPLY_ROUTE|BRANCH_ROUTE|LOCAL_ROUTE },
+  { "is_in_subnet", (cmd_function)w_ip_is_in_subnet, 2, fixup_spve_spve, 0,
+		REQUEST_ROUTE|FAILURE_ROUTE|ONREPLY_ROUTE|BRANCH_ROUTE|LOCAL_ROUTE },
+  { 0, 0, 0, 0, 0, 0 }
+};
+
+struct module_exports exports = {
+	"ipops",
+	MOD_TYPE_DEFAULT,/* class of this module */
+	MODULE_VERSION,
+	DEFAULT_DLFLAGS, /* dlopen flags */
+	0,
+	cmds,
+	0,
+	0,
+	0,           /* exported statistics */
+	0,     /* exported MI functions */
+	0,           /* exported pseudo-variables */
+	0,           /* extra processes */
+	0,
+	0,           /* reply processing */
+	0, /* destroy function */
+	0	
+};
+
+/*
+ * Module internal functions
+ */
+
+/*! \brief Return 1 if both pure IP's are equal, 0 otherwise. */
+static int _compare_ips(char *ip1, size_t len1, enum enum_ip_type ip1_type, char *ip2, size_t len2, enum enum_ip_type ip2_type)
+{
+  struct in_addr in_addr1, in_addr2;
+  struct in6_addr in6_addr1, in6_addr2;
+  char _ip1[INET6_ADDRSTRLEN], _ip2[INET6_ADDRSTRLEN];
+  
+  // Not same IP type, return false.
+  if (ip1_type != ip2_type)
+    return 0;
+
+  memcpy(_ip1, ip1, len1);
+  _ip1[len1] = '\0';
+  memcpy(_ip2, ip2, len2);
+  _ip2[len2] = '\0';
+
+  switch(ip1_type) {
+    // Comparing IPv4 with IPv4.
+    case(ip_type_ipv4):
+      if (inet_pton(AF_INET, _ip1, &in_addr1) == 0)  return 0;
+      if (inet_pton(AF_INET, _ip2, &in_addr2) == 0)  return 0;
+      if (in_addr1.s_addr == in_addr2.s_addr)
+        return 1;
+      else
+        return 0;
+      break;
+    // Comparing IPv6 with IPv6.
+    case(ip_type_ipv6):
+      if (inet_pton(AF_INET6, _ip1, &in6_addr1) != 1)  return 0;
+      if (inet_pton(AF_INET6, _ip2, &in6_addr2) != 1)  return 0;
+      if (memcmp(in6_addr1.s6_addr, in6_addr2.s6_addr, sizeof(in6_addr1.s6_addr)) == 0)
+        return 1;
+      else
+        return 0;
+      break;
+    default:
+      return 0;
+      break;
+  }
+}
+
+/*! \brief Return 1 if IP1 is in the subnet given by IP2 and the netmask, 0 otherwise. */
+int _ip_is_in_subnet(char *ip1, size_t len1, enum enum_ip_type ip1_type, char *ip2, size_t len2, enum enum_ip_type ip2_type, int netmask)
+{
+	struct in_addr in_addr1, in_addr2;
+	struct in6_addr in6_addr1, in6_addr2;
+	char _ip1[INET6_ADDRSTRLEN], _ip2[INET6_ADDRSTRLEN];
+	uint32_t ipv4_mask;
+	uint8_t ipv6_mask[16];
+	int i;
+
+	// Not same IP type, return false.
+	if (ip1_type != ip2_type)
+		return 0;
+
+	memcpy(_ip1, ip1, len1);
+	_ip1[len1] = '\0';
+	memcpy(_ip2, ip2, len2);
+	_ip2[len2] = '\0';
+
+	switch(ip1_type) {
+		// Comparing IPv4 with IPv4.
+		case(ip_type_ipv4):
+			if (inet_pton(AF_INET, _ip1, &in_addr1) == 0)  return 0;
+			if (inet_pton(AF_INET, _ip2, &in_addr2) == 0)  return 0;
+			if (netmask <0 || netmask > 32)  return 0;
+			if (netmask == 32) ipv4_mask = 0xFFFFFFFF;
+			else ipv4_mask = htonl(~(0xFFFFFFFF >> netmask));
+			if ((in_addr1.s_addr & ipv4_mask) == in_addr2.s_addr)
+				return 1;
+			else
+				return 0;
+			break;
+			// Comparing IPv6 with IPv6.
+		case(ip_type_ipv6):
+			if (inet_pton(AF_INET6, _ip1, &in6_addr1) != 1)  return 0;
+			if (inet_pton(AF_INET6, _ip2, &in6_addr2) != 1)  return 0;
+			if (netmask <0 || netmask > 128)  return 0;
+			for (i=0; i<16; i++)
+			{
+				if (netmask > ((i+1)*8)) ipv6_mask[i] = 0xFF;
+				else if (netmask > (i*8))  ipv6_mask[i] = ~(0xFF >> (netmask-(i*8)));
+				else ipv6_mask[i] = 0x00;
+			}
+			for (i=0; i<16; i++)  in6_addr1.s6_addr[i] &= ipv6_mask[i];
+			if (memcmp(in6_addr1.s6_addr, in6_addr2.s6_addr, sizeof(in6_addr1.s6_addr)) == 0)
+				return 1;
+			else
+				return 0;
+			break;
+		default:
+			return 0;
+			break;
+	}
+}
+
+
+
+/*
+ * Script functions
+ */
+
+/*! \brief Return true if the given argument (string or pv) is a valid IPv4, IPv6 or IPv6 reference. */
+static int w_is_ip(struct sip_msg* _msg, char* _s)
+{
+  str string;
+  
+  if (_s == NULL) {
+    LM_ERR("bad parameter\n");
+    return -2;
+  }
+  
+  if (fixup_get_svalue(_msg, (gparam_p)_s, &string))
+  {
+    LM_ERR("cannot print the format for string\n");
+    return -3;
+  }
+  
+  if (ip_parser_execute(string.s, string.len) != ip_type_error)
+    return 1;
+  else
+    return -1;
+}
+
+
+/*! \brief Return true if the given argument (string or pv) is a valid IPv4 or IPv6. */
+static int w_is_pure_ip(struct sip_msg* _msg, char* _s)
+{
+  str string;
+  
+  if (_s == NULL) {
+    LM_ERR("bad parameter\n");
+    return -2;
+  }
+  
+  if (fixup_get_svalue(_msg, (gparam_p)_s, &string))
+  {
+    LM_ERR("cannot print the format for string\n");
+    return -3;
+  }
+
+  switch(ip_parser_execute(string.s, string.len)) {
+    case(ip_type_ipv4):
+      return 1;
+      break;
+    case(ip_type_ipv6):
+      return 1;
+      break;
+    default:
+      return -1;
+      break;
+  }
+}
+
+
+/*! \brief Return true if the given argument (string or pv) is a valid IPv4. */
+static int w_is_ipv4(struct sip_msg* _msg, char* _s)
+{
+  str string;
+  
+  if (_s == NULL) {
+    LM_ERR("bad parameter\n");
+    return -2;
+  }
+  
+  if (fixup_get_svalue(_msg, (gparam_p)_s, &string))
+  {
+    LM_ERR("cannot print the format for string\n");
+    return -3;
+  }
+
+  if (ip_parser_execute(string.s, string.len) == ip_type_ipv4)
+    return 1;
+  else
+    return -1;
+}
+
+
+/*! \brief Return true if the given argument (string or pv) is a valid IPv6. */
+static int w_is_ipv6(struct sip_msg* _msg, char* _s)
+{
+  str string;
+  
+  if (_s == NULL) {
+    LM_ERR("bad parameter\n");
+    return -2;
+  }
+  
+  if (fixup_get_svalue(_msg, (gparam_p)_s, &string))
+  {
+    LM_ERR("cannot print the format for string\n");
+    return -3;
+  }
+  
+  if (ip_parser_execute(string.s, string.len) == ip_type_ipv6)
+    return 1;
+  else
+    return -1;
+}
+
+
+/*! \brief Return true if the given argument (string or pv) is a valid IPv6 reference. */
+static int w_is_ipv6_reference(struct sip_msg* _msg, char* _s)
+{
+  str string;
+  
+  if (_s == NULL) {
+    LM_ERR("bad parameter\n");
+    return -2;
+  }
+  
+  if (fixup_get_svalue(_msg, (gparam_p)_s, &string))
+  {
+    LM_ERR("cannot print the format for string\n");
+    return -3;
+  }
+  
+  if (ip_parser_execute(string.s, string.len) == ip_type_ipv6_reference)
+    return 1;
+  else
+    return -1;
+}
+
+
+/*! \brief Return the IP type of the given argument (string or pv): 1 = IPv4, 2 = IPv6, 3 = IPv6 refenrece, -1 = invalid IP. */
+static int w_ip_type(struct sip_msg* _msg, char* _s)
+{
+  str string;
+  
+  if (_s == NULL) {
+    LM_ERR("bad parameter\n");
+    return -2;
+  }
+  
+  if (fixup_get_svalue(_msg, (gparam_p)_s, &string))
+  {
+    LM_ERR("cannot print the format for string\n");
+    return -3;
+  }
+  
+  switch (ip_parser_execute(string.s, string.len)) {
+    case(ip_type_ipv4):
+      return 1;
+      break;
+    case(ip_type_ipv6):
+      return 2;
+      break;
+    case(ip_type_ipv6_reference):
+      return 3;
+      break;
+    default:
+      return -1;
+      break;
+  }
+}
+
+
+/*! \brief Return true if both IP's (string or pv) are equal. This function also allows comparing an IPv6 with an IPv6 reference. */
+static int w_compare_ips(struct sip_msg* _msg, char* _s1, char* _s2)
+{
+  str string1, string2;
+  enum enum_ip_type ip1_type, ip2_type;
+  
+  if (_s1 == NULL || _s2 == NULL ) {
+    LM_ERR("bad parameters\n");
+    return -2;
+  }
+  
+  if (fixup_get_svalue(_msg, (gparam_p)_s1, &string1))
+  {
+    LM_ERR("cannot print the format for first string\n");
+    return -3;
+  }
+
+  if (fixup_get_svalue(_msg, (gparam_p)_s2, &string2))
+  {
+    LM_ERR("cannot print the format for second string\n");
+    return -3;
+  }
+
+  switch(ip1_type = ip_parser_execute(string1.s, string1.len)) {
+    case(ip_type_error):
+      return -1;
+      break;
+    case(ip_type_ipv6_reference):
+      string1.s += 1;
+      string1.len -= 2;
+      ip1_type = ip_type_ipv6;
+      break;
+    default:
+      break;
+  }
+  switch(ip2_type = ip_parser_execute(string2.s, string2.len)) {
+    case(ip_type_error):
+      return -1;
+      break;
+    case(ip_type_ipv6_reference):
+      string2.s += 1;
+      string2.len -= 2;
+      ip2_type = ip_type_ipv6;
+      break;
+    default:
+      break;
+  }
+
+  if (_compare_ips(string1.s, string1.len, ip1_type, string2.s, string2.len, ip2_type))
+    return 1;
+  else
+    return -1;
+}
+
+
+/*! \brief Return true if both pure IP's (string or pv) are equal. IPv6 references not allowed. */
+static int w_compare_pure_ips(struct sip_msg* _msg, char* _s1, char* _s2)
+{
+  str string1, string2;
+  enum enum_ip_type ip1_type, ip2_type;
+  
+  if (_s1 == NULL || _s2 == NULL ) {
+    LM_ERR("bad parameters\n");
+    return -2;
+  }
+  
+  if (fixup_get_svalue(_msg, (gparam_p)_s1, &string1))
+  {
+    LM_ERR("cannot print the format for first string\n");
+    return -3;
+  }
+  
+  if (fixup_get_svalue(_msg, (gparam_p)_s2, &string2))
+  {
+    LM_ERR("cannot print the format for second string\n");
+    return -3;
+  }
+
+  switch(ip1_type = ip_parser_execute(string1.s, string1.len)) {
+    case(ip_type_error):
+      return -1;
+      break;
+    case(ip_type_ipv6_reference):
+      return -1;
+      break;
+    default:
+      break;
+  }
+  switch(ip2_type = ip_parser_execute(string2.s, string2.len)) {
+    case(ip_type_error):
+      return -1;
+      break;
+    case(ip_type_ipv6_reference):
+      return -1;
+      break;
+    default:
+      break;
+  }
+  
+  if (_compare_ips(string1.s, string1.len, ip1_type, string2.s, string2.len, ip2_type))
+    return 1;
+  else
+    return -1;
+}
+
+/*! \brief Return true if the first IP (string or pv) is within the subnet defined by the second IP in CIDR notation. IPv6 references not allowed. */
+static int w_ip_is_in_subnet(struct sip_msg* _msg, char* _s1, char* _s2)
+{
+	str string1, string2;
+	enum enum_ip_type ip1_type, ip2_type;
+	char *cidr_pos = NULL;
+	int netmask = 0;
+
+	if (_s1 == NULL || _s2 == NULL ) {
+		LM_ERR("bad parameters\n");
+		return -2;
+	}
+
+	if (fixup_get_svalue(_msg, (gparam_p)_s1, &string1))
+	{
+		LM_ERR("cannot print the format for first string\n");
+		return -3;
+	}
+
+	if (fixup_get_svalue(_msg, (gparam_p)_s2, &string2))
+	{
+		LM_ERR("cannot print the format for second string\n");
+		return -3;
+	}
+
+	switch(ip1_type = ip_parser_execute(string1.s, string1.len)) {
+		case(ip_type_error):
+			return -1;
+			break;
+		case(ip_type_ipv6_reference):
+			return -1;
+			break;
+		default:
+			break;
+	}
+	cidr_pos = string2.s + string2.len - 1;
+	while (cidr_pos > string2.s)
+	{
+		if (*cidr_pos == '/')
+		{
+			string2.len = (cidr_pos - string2.s);
+			netmask = atoi(cidr_pos+1);
+			break;
+		}
+		cidr_pos--;
+	}
+	switch(ip2_type = ip_parser_execute(string2.s, string2.len)) {
+		case(ip_type_error):
+			return -1;
+			break;
+		case(ip_type_ipv6_reference):
+			return -1;
+			break;
+		default:
+			break;
+	}
+
+	if (netmask == 0)
+	{
+		if (_compare_ips(string1.s, string1.len, ip1_type, string2.s, string2.len, ip2_type))
+			return 1;
+		else
+			return -1;
+	}
+	else
+	{
+		if (_ip_is_in_subnet(string1.s, string1.len, ip1_type, string2.s, string2.len, ip2_type, netmask))
+			return 1;
+		else
+			return -1;
+	}
+}
+
+
+/*! \brief Return true if the given argument (string or pv) is a valid RFC 1918 IPv4 (private address). */
+static int w_is_ip_rfc1918(struct sip_msg* _msg, char* _s)
+{
+  str string;
+  
+  if (_s == NULL) {
+    LM_ERR("bad parameter\n");
+    return -2;
+  }
+  
+  if (fixup_get_svalue(_msg, (gparam_p)_s, &string))
+  {
+    LM_ERR("cannot print the format for string\n");
+    return -3;
+  }
+  
+  if (rfc1918_parser_execute(string.s, string.len) == 1)
+    return 1;
+  else
+    return -1;
+}
diff --git a/modules/ipops/rfc1918_parser.c b/modules/ipops/rfc1918_parser.c
new file mode 100644
index 0000000..f39fff0
--- /dev/null
+++ b/modules/ipops/rfc1918_parser.c
@@ -0,0 +1,399 @@
+
+#line 1 "rfc1918_parser.rl"
+#include "rfc1918_parser.h"
+
+
+/** Ragel machine **/
+
+#line 21 "rfc1918_parser.rl"
+
+
+
+/** Data **/
+
+#line 15 "rfc1918_parser.c"
+static const int rfc1918_parser_start = 1;
+static const int rfc1918_parser_first_final = 28;
+static const int rfc1918_parser_error = 0;
+
+static const int rfc1918_parser_en_main = 1;
+
+
+#line 26 "rfc1918_parser.rl"
+
+
+/** exec **/
+unsigned int rfc1918_parser_execute(const char *str, size_t len)
+{
+  int cs = 0;
+  const char *p, *pe;
+  unsigned int is_ip_rfc1918 = 0;
+
+  p = str;
+  pe = str+len;
+
+  
+#line 37 "rfc1918_parser.c"
+	{
+	cs = rfc1918_parser_start;
+	}
+
+#line 39 "rfc1918_parser.rl"
+  
+#line 44 "rfc1918_parser.c"
+	{
+	if ( p == pe )
+		goto _test_eof;
+	switch ( cs )
+	{
+case 1:
+	if ( (*p) == 49 )
+		goto st2;
+	goto st0;
+st0:
+cs = 0;
+	goto _out;
+st2:
+	if ( ++p == pe )
+		goto _test_eof2;
+case 2:
+	switch( (*p) ) {
+		case 48: goto st3;
+		case 55: goto st17;
+		case 57: goto st23;
+	}
+	goto st0;
+st3:
+	if ( ++p == pe )
+		goto _test_eof3;
+case 3:
+	if ( (*p) == 46 )
+		goto st4;
+	goto st0;
+st4:
+	if ( ++p == pe )
+		goto _test_eof4;
+case 4:
+	switch( (*p) ) {
+		case 48: goto st5;
+		case 49: goto st13;
+		case 50: goto st15;
+	}
+	if ( 51 <= (*p) && (*p) <= 57 )
+		goto st14;
+	goto st0;
+st5:
+	if ( ++p == pe )
+		goto _test_eof5;
+case 5:
+	if ( (*p) == 46 )
+		goto st6;
+	goto st0;
+st6:
+	if ( ++p == pe )
+		goto _test_eof6;
+case 6:
+	switch( (*p) ) {
+		case 48: goto st7;
+		case 49: goto st9;
+		case 50: goto st11;
+	}
+	if ( 51 <= (*p) && (*p) <= 57 )
+		goto st10;
+	goto st0;
+st7:
+	if ( ++p == pe )
+		goto _test_eof7;
+case 7:
+	if ( (*p) == 46 )
+		goto st8;
+	goto st0;
+st8:
+	if ( ++p == pe )
+		goto _test_eof8;
+case 8:
+	switch( (*p) ) {
+		case 48: goto tr16;
+		case 49: goto tr17;
+		case 50: goto tr18;
+	}
+	if ( 51 <= (*p) && (*p) <= 57 )
+		goto tr19;
+	goto st0;
+tr16:
+#line 8 "rfc1918_parser.rl"
+	{
+    is_ip_rfc1918 = 1;
+  }
+	goto st28;
+st28:
+	if ( ++p == pe )
+		goto _test_eof28;
+case 28:
+#line 134 "rfc1918_parser.c"
+	goto st0;
+tr17:
+#line 8 "rfc1918_parser.rl"
+	{
+    is_ip_rfc1918 = 1;
+  }
+	goto st29;
+st29:
+	if ( ++p == pe )
+		goto _test_eof29;
+case 29:
+#line 146 "rfc1918_parser.c"
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto tr19;
+	goto st0;
+tr19:
+#line 8 "rfc1918_parser.rl"
+	{
+    is_ip_rfc1918 = 1;
+  }
+	goto st30;
+st30:
+	if ( ++p == pe )
+		goto _test_eof30;
+case 30:
+#line 160 "rfc1918_parser.c"
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto tr16;
+	goto st0;
+tr18:
+#line 8 "rfc1918_parser.rl"
+	{
+    is_ip_rfc1918 = 1;
+  }
+	goto st31;
+st31:
+	if ( ++p == pe )
+		goto _test_eof31;
+case 31:
+#line 174 "rfc1918_parser.c"
+	if ( (*p) == 53 )
+		goto tr31;
+	if ( (*p) > 52 ) {
+		if ( 54 <= (*p) && (*p) <= 57 )
+			goto tr16;
+	} else if ( (*p) >= 48 )
+		goto tr19;
+	goto st0;
+tr31:
+#line 8 "rfc1918_parser.rl"
+	{
+    is_ip_rfc1918 = 1;
+  }
+	goto st32;
+st32:
+	if ( ++p == pe )
+		goto _test_eof32;
+case 32:
+#line 193 "rfc1918_parser.c"
+	if ( 48 <= (*p) && (*p) <= 53 )
+		goto tr16;
+	goto st0;
+st9:
+	if ( ++p == pe )
+		goto _test_eof9;
+case 9:
+	if ( (*p) == 46 )
+		goto st8;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st10;
+	goto st0;
+st10:
+	if ( ++p == pe )
+		goto _test_eof10;
+case 10:
+	if ( (*p) == 46 )
+		goto st8;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st7;
+	goto st0;
+st11:
+	if ( ++p == pe )
+		goto _test_eof11;
+case 11:
+	switch( (*p) ) {
+		case 46: goto st8;
+		case 53: goto st12;
+	}
+	if ( (*p) > 52 ) {
+		if ( 54 <= (*p) && (*p) <= 57 )
+			goto st7;
+	} else if ( (*p) >= 48 )
+		goto st10;
+	goto st0;
+st12:
+	if ( ++p == pe )
+		goto _test_eof12;
+case 12:
+	if ( (*p) == 46 )
+		goto st8;
+	if ( 48 <= (*p) && (*p) <= 53 )
+		goto st7;
+	goto st0;
+st13:
+	if ( ++p == pe )
+		goto _test_eof13;
+case 13:
+	if ( (*p) == 46 )
+		goto st6;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st14;
+	goto st0;
+st14:
+	if ( ++p == pe )
+		goto _test_eof14;
+case 14:
+	if ( (*p) == 46 )
+		goto st6;
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st5;
+	goto st0;
+st15:
+	if ( ++p == pe )
+		goto _test_eof15;
+case 15:
+	switch( (*p) ) {
+		case 46: goto st6;
+		case 53: goto st16;
+	}
+	if ( (*p) > 52 ) {
+		if ( 54 <= (*p) && (*p) <= 57 )
+			goto st5;
+	} else if ( (*p) >= 48 )
+		goto st14;
+	goto st0;
+st16:
+	if ( ++p == pe )
+		goto _test_eof16;
+case 16:
+	if ( (*p) == 46 )
+		goto st6;
+	if ( 48 <= (*p) && (*p) <= 53 )
+		goto st5;
+	goto st0;
+st17:
+	if ( ++p == pe )
+		goto _test_eof17;
+case 17:
+	if ( (*p) == 50 )
+		goto st18;
+	goto st0;
+st18:
+	if ( ++p == pe )
+		goto _test_eof18;
+case 18:
+	if ( (*p) == 46 )
+		goto st19;
+	goto st0;
+st19:
+	if ( ++p == pe )
+		goto _test_eof19;
+case 19:
+	switch( (*p) ) {
+		case 49: goto st20;
+		case 50: goto st21;
+		case 51: goto st22;
+	}
+	goto st0;
+st20:
+	if ( ++p == pe )
+		goto _test_eof20;
+case 20:
+	if ( 54 <= (*p) && (*p) <= 57 )
+		goto st5;
+	goto st0;
+st21:
+	if ( ++p == pe )
+		goto _test_eof21;
+case 21:
+	if ( 48 <= (*p) && (*p) <= 57 )
+		goto st5;
+	goto st0;
+st22:
+	if ( ++p == pe )
+		goto _test_eof22;
+case 22:
+	if ( 48 <= (*p) && (*p) <= 49 )
+		goto st5;
+	goto st0;
+st23:
+	if ( ++p == pe )
+		goto _test_eof23;
+case 23:
+	if ( (*p) == 50 )
+		goto st24;
+	goto st0;
+st24:
+	if ( ++p == pe )
+		goto _test_eof24;
+case 24:
+	if ( (*p) == 46 )
+		goto st25;
+	goto st0;
+st25:
+	if ( ++p == pe )
+		goto _test_eof25;
+case 25:
+	if ( (*p) == 49 )
+		goto st26;
+	goto st0;
+st26:
+	if ( ++p == pe )
+		goto _test_eof26;
+case 26:
+	if ( (*p) == 54 )
+		goto st27;
+	goto st0;
+st27:
+	if ( ++p == pe )
+		goto _test_eof27;
+case 27:
+	if ( (*p) == 56 )
+		goto st5;
+	goto st0;
+	}
+	_test_eof2: cs = 2; goto _test_eof; 
+	_test_eof3: cs = 3; goto _test_eof; 
+	_test_eof4: cs = 4; goto _test_eof; 
+	_test_eof5: cs = 5; goto _test_eof; 
+	_test_eof6: cs = 6; goto _test_eof; 
+	_test_eof7: cs = 7; goto _test_eof; 
+	_test_eof8: cs = 8; goto _test_eof; 
+	_test_eof28: cs = 28; goto _test_eof; 
+	_test_eof29: cs = 29; goto _test_eof; 
+	_test_eof30: cs = 30; goto _test_eof; 
+	_test_eof31: cs = 31; goto _test_eof; 
+	_test_eof32: cs = 32; goto _test_eof; 
+	_test_eof9: cs = 9; goto _test_eof; 
+	_test_eof10: cs = 10; goto _test_eof; 
+	_test_eof11: cs = 11; goto _test_eof; 
+	_test_eof12: cs = 12; goto _test_eof; 
+	_test_eof13: cs = 13; goto _test_eof; 
+	_test_eof14: cs = 14; goto _test_eof; 
+	_test_eof15: cs = 15; goto _test_eof; 
+	_test_eof16: cs = 16; goto _test_eof; 
+	_test_eof17: cs = 17; goto _test_eof; 
+	_test_eof18: cs = 18; goto _test_eof; 
+	_test_eof19: cs = 19; goto _test_eof; 
+	_test_eof20: cs = 20; goto _test_eof; 
+	_test_eof21: cs = 21; goto _test_eof; 
+	_test_eof22: cs = 22; goto _test_eof; 
+	_test_eof23: cs = 23; goto _test_eof; 
+	_test_eof24: cs = 24; goto _test_eof; 
+	_test_eof25: cs = 25; goto _test_eof; 
+	_test_eof26: cs = 26; goto _test_eof; 
+	_test_eof27: cs = 27; goto _test_eof; 
+
+	_test_eof: {}
+	_out: {}
+	}
+
+#line 40 "rfc1918_parser.rl"
+
+  return is_ip_rfc1918;
+}
+
diff --git a/modules/ipops/rfc1918_parser.h b/modules/ipops/rfc1918_parser.h
new file mode 100644
index 0000000..e9ef634
--- /dev/null
+++ b/modules/ipops/rfc1918_parser.h
@@ -0,0 +1,16 @@
+/*
+ * Warning: This file is auto generated from a ragel syntax (rfc1918_parser.rl),
+ * do not change it!
+ */   
+
+#ifndef rfc1918_parser_h
+#define rfc1918_parser_h
+
+
+#include <sys/types.h>
+
+
+unsigned int rfc1918_parser_execute(const char *str, size_t len);
+
+
+#endif
diff --git a/modules/ipops/rfc1918_parser.rl b/modules/ipops/rfc1918_parser.rl
new file mode 100644
index 0000000..cd2903a
--- /dev/null
+++ b/modules/ipops/rfc1918_parser.rl
@@ -0,0 +1,43 @@
+#include "rfc1918_parser.h"
+
+
+/** Ragel machine **/
+%%{
+  machine rfc1918_parser;
+
+  action is_rfc1918 {
+    is_ip_rfc1918 = 1;
+  }
+
+  DIGIT                = "0".."9";
+  dec_octet            = DIGIT | ( 0x31..0x39 DIGIT ) | ( "1" DIGIT{2} ) |
+                         ( "2" 0x30..0x34 DIGIT ) | ( "25" 0x30..0x35 );
+
+  RFC1918_address      = ( "10." dec_octet "." dec_octet "." dec_octet ) |
+                         ( "172." ( ( "1" "6".."9" ) | ( "2" DIGIT ) | ( "3" "0".."1" ) ) "." dec_octet "." dec_octet ) |
+                         ( "192.168." dec_octet "." dec_octet );
+
+   main                := RFC1918_address @is_rfc1918;
+}%%
+
+
+/** Data **/
+%% write data;
+
+
+/** exec **/
+unsigned int rfc1918_parser_execute(const char *str, size_t len)
+{
+  int cs = 0;
+  const char *p, *pe;
+  unsigned int is_ip_rfc1918 = 0;
+
+  p = str;
+  pe = str+len;
+
+  %% write init;
+  %% write exec;
+
+  return is_ip_rfc1918;
+}
+
diff --git a/modules/load_balancer/lb_data.c b/modules/load_balancer/lb_data.c
index 3c81037..2d85092 100644
--- a/modules/load_balancer/lb_data.c
+++ b/modules/load_balancer/lb_data.c
@@ -215,7 +215,7 @@ static int lb_set_resource_bitmask(struct lb_resource *res, unsigned int bit)
 
 
 int add_lb_dsturi( struct lb_data *data, int id, int group, char *uri,
-											char* resource, unsigned int flags)
+											char* resource, unsigned int flags, struct socket_info *sock)
 {
 	struct lb_res_str_list *lb_rl;
 	struct lb_res_str *r;
@@ -269,6 +269,7 @@ int add_lb_dsturi( struct lb_data *data, int id, int group, char *uri,
 	dst->group = group;
 	dst->rmap_no = lb_rl->n;
 	dst->flags = flags;
+	dst->sock = sock;
 
 	/* add or update resource list */
 	for( i=0 ; i<lb_rl->n ; i++) {
diff --git a/modules/load_balancer/lb_data.h b/modules/load_balancer/lb_data.h
index 3cc9c50..e67dffc 100644
--- a/modules/load_balancer/lb_data.h
+++ b/modules/load_balancer/lb_data.h
@@ -75,6 +75,7 @@ struct lb_dst {
 	unsigned short int ports[LB_MAX_IPS]; /* Port of the request URI */
 	unsigned short int protos[LB_MAX_IPS]; /* Protocol of the request URI */
 	unsigned short ips_cnt;
+	struct socket_info *sock;
 	struct lb_dst *next;
 };
 
@@ -89,7 +90,7 @@ struct lb_data {
 struct lb_data* load_lb_data(void);
 
 int add_lb_dsturi( struct lb_data *data, int id, int group, char *uri,
-		char* resource, unsigned int flags);
+		char* resource, unsigned int flags, struct socket_info *sock);
 
 void free_lb_data(struct lb_data *data);
 
diff --git a/modules/load_balancer/lb_db.c b/modules/load_balancer/lb_db.c
index c23e0f5..02f416f 100644
--- a/modules/load_balancer/lb_db.c
+++ b/modules/load_balancer/lb_db.c
@@ -29,6 +29,7 @@
 
 #include "../../db/db.h"
 #include "lb_db.h"
+#include "../../socket_info.h"
 
 #define LB_TABLE_VERSION  2
 
@@ -37,6 +38,7 @@ str lb_grpid_column			=	str_init(LB_GRP_ID_COL);
 str lb_dsturi_column		=	str_init(LB_DST_URI_COL);
 str lb_resource_column		=	str_init(LB_RESOURCES_COL);
 str lb_pmode_column			=	str_init(LB_PMODE_COL);
+str lb_socket_column			=	str_init(LB_SOCKET_COL);
 str lb_table_name			=	str_init(LB_TABLE_NAME);
 
 
@@ -113,7 +115,7 @@ int init_lb_db(const str *db_url, char *table)
 
 int lb_db_load_data( struct lb_data *data)
 {
-	db_key_t columns[5];
+	db_key_t columns[6];
 	db_res_t* res = NULL;
 	db_row_t* row;
 	int i, n;
@@ -121,6 +123,9 @@ int lb_db_load_data( struct lb_data *data)
 	int id, group, pmode;
 	unsigned int flags;
 	int no_rows = 10;
+	struct socket_info *sock;
+	str s_sock, host;
+	int proto, port;
 
 
 	lb_dbf.use_table( lb_db_handle, &lb_table_name);
@@ -130,20 +135,21 @@ int lb_db_load_data( struct lb_data *data)
 	columns[2] = &lb_dsturi_column;
 	columns[3] = &lb_resource_column;
 	columns[4] = &lb_pmode_column;
+	columns[5] = &lb_socket_column;
 
 	if (0/*DB_CAPABILITY(lb_dbf, DB_CAP_FETCH))*/) {
-		if ( lb_dbf.query( lb_db_handle, 0, 0, 0, columns, 0, 5, 0, 0 ) < 0) {
+		if ( lb_dbf.query( lb_db_handle, 0, 0, 0, columns, 0, 6, 0, 0 ) < 0) {
 			LM_ERR("DB query failed\n");
 			return -1;
 		}
-		no_rows = estimate_available_rows( 4+4+64+256+8, 5/*cols*/);
+		no_rows = estimate_available_rows( 4+4+64+256+8+128, 6/*cols*/);
 		if (no_rows==0) no_rows = 10;
 		if(lb_dbf.fetch_result( lb_db_handle, &res, no_rows)<0) {
 			LM_ERR("Error fetching rows\n");
 			return -1;
 		}
 	} else {
-		if ( lb_dbf.query( lb_db_handle, 0, 0, 0, columns, 0, 5, 0, &res)<0) {
+		if ( lb_dbf.query( lb_db_handle, 0, 0, 0, columns, 0, 6, 0, &res)<0) {
 			LM_ERR("DB query failed\n");
 			return -1;
 		}
@@ -182,9 +188,31 @@ int lb_db_load_data( struct lb_data *data)
 			} else if (pmode>=2) {
 				flags |= LB_DST_PING_PERM_FLAG;
 			}
+			/*SOCKET column */
+			check_val( ROW_VALUES(row)+5, DB_STRING, 1, 1);
+			if ( !VAL_NULL(ROW_VALUES(row)+5) &&
+					(s_sock.s=(char*)VAL_STRING(ROW_VALUES(row)+5))[0]!=0 ) {
+				s_sock.len = strlen(s_sock.s);
+				if (parse_phostport( s_sock.s, s_sock.len, &host.s, &host.len,
+							&port, &proto)!=0){
+					LM_ERR("socket description <%.*s> "
+							"is not valid -> ignoring socket\n",
+							s_sock.len,s_sock.s);
+					sock = NULL;
+				} else {
+					sock = grep_sock_info( &host, port, proto);
+					if (sock == NULL) {
+						LM_ERR("socket <%.*s> is not local to "
+								"OpenSIPS (we must listen on it) -> ignoring socket\n",
+								s_sock.len,s_sock.s);
+					}
+				}
+			} else {
+				sock = NULL;
+			}
 
 			/* add the destinaton definition in */
-			if ( add_lb_dsturi( data, id, group, uri, resource, flags)<0 ) {
+			if ( add_lb_dsturi( data, id, group, uri, resource, flags, sock)<0 ) {
 				LM_ERR("failed to add destination %d -> skipping\n",n);
 				continue;
 			}
diff --git a/modules/load_balancer/lb_db.h b/modules/load_balancer/lb_db.h
index 1844782..c5b1571 100644
--- a/modules/load_balancer/lb_db.h
+++ b/modules/load_balancer/lb_db.h
@@ -35,6 +35,7 @@
 #define LB_DST_URI_COL   "dst_uri"
 #define LB_RESOURCES_COL "resources"
 #define LB_PMODE_COL     "probe_mode"
+#define LB_SOCKET_COL    "socket"
 
 #include "../../str.h"
 #include "lb_data.h"
diff --git a/modules/load_balancer/lb_prober.c b/modules/load_balancer/lb_prober.c
index 9cc16bf..78ca936 100644
--- a/modules/load_balancer/lb_prober.c
+++ b/modules/load_balancer/lb_prober.c
@@ -59,6 +59,7 @@ static void lb_probing_callback( struct cell *t, int type,
 void lb_do_probing(struct lb_data *data)
 {
 	struct lb_dst *dst;
+	dlg_t *dlg;
 
 	/* go through all destinations */
 	for( dst = data->dsts ; dst ; dst=dst->next ) {
@@ -72,12 +73,20 @@ void lb_do_probing(struct lb_data *data)
 			)
 			continue;
 
-		if (lb_tmb.t_request( &lb_probe_method, &dst->uri, &dst->uri,
-		&lb_probe_from, NULL, NULL, NULL, lb_probing_callback,
-		(void*)(long)dst->id, NULL) < 0) {
-			LM_ERR("probing failed\n");
+
+		/* Execute the Dialog using the "request"-Method of the
+		 * TM-Module.*/
+		if (lb_tmb.new_auto_dlg_uac(&lb_probe_from, &dst->uri, dst->sock, &dlg)!=0) {
+			LM_ERR("failed to create new TM dlg\n");
+			continue;
 		}
+		dlg->state = DLG_CONFIRMED;
 
+		if (lb_tmb.t_request_within(&lb_probe_method, NULL, NULL, dlg,
+					lb_probing_callback, (void*)(long)dst->id, NULL) < 0) {
+			LM_ERR("unable to execute dialog\n");
+		}
+		lb_tmb.free_dlg(dlg);
 
 	}
 
diff --git a/modules/python/python_iface.c b/modules/python/python_iface.c
index cbffe8d..614ced7 100644
--- a/modules/python/python_iface.c
+++ b/modules/python/python_iface.c
@@ -28,6 +28,21 @@
 
 /* Return the number of arguments of the application command line */
 static PyObject*
+opensips_LM_INFO(PyObject *self, PyObject *args)
+{
+    char *msg;
+
+    if(!PyArg_ParseTuple(args, "s:LM_ERR", &msg))
+        return NULL;
+
+    LM_INFO("%s", msg);
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+/* Return the number of arguments of the application command line */
+static PyObject*
 opensips_LM_ERR(PyObject *self, PyObject *args)
 {
     char *msg;
@@ -44,5 +59,7 @@ opensips_LM_ERR(PyObject *self, PyObject *args)
 PyMethodDef OpenSIPSMethods[] = {
     {"LM_ERR", opensips_LM_ERR, METH_VARARGS,
      "Pring error message."},
+    {"LM_INFO", opensips_LM_INFO, METH_VARARGS,
+     "Pring error message."},
     {NULL, NULL, 0, NULL}
 };
diff --git a/modules/regex/regex_mod.c b/modules/regex/regex_mod.c
index 1f7f2ab..2a1db16 100644
--- a/modules/regex/regex_mod.c
+++ b/modules/regex/regex_mod.c
@@ -119,7 +119,7 @@ static cmd_export_t cmds[] =
 	{ "pcre_match", (cmd_function)w_pcre_match, 2, fixup_spve_spve, 0,
 		REQUEST_ROUTE|FAILURE_ROUTE|ONREPLY_ROUTE|BRANCH_ROUTE|LOCAL_ROUTE|
 		STARTUP_ROUTE|TIMER_ROUTE|EVENT_ROUTE},
-	{ "pcre_match_group", (cmd_function)w_pcre_match_group, 2, fixup_spve_uint, 0,
+	{ "pcre_match_group", (cmd_function)w_pcre_match_group, 2, fixup_spve_spve, 0,
 		REQUEST_ROUTE|FAILURE_ROUTE|ONREPLY_ROUTE|BRANCH_ROUTE|LOCAL_ROUTE|
 		STARTUP_ROUTE|TIMER_ROUTE|EVENT_ROUTE},
 	{ "pcre_match_group", (cmd_function)w_pcre_match_group, 1, fixup_spve_null, 0,
@@ -588,6 +588,27 @@ static int w_pcre_match(struct sip_msg* _msg, char* _s1, char* _s2)
 	return 1;
 }
 
+/* function to manipulate the variable instead of static group id */
+static int regex_get_var_svalue(struct sip_msg *msg, gparam_p gp, str *val, int n)
+{
+	#define MAX_BUF  64
+	static char buf[2][MAX_BUF];
+	str tmp;
+
+	if (gp->type==GPARAM_TYPE_STR) {
+		*val = gp->v.sval;
+		return 0;
+	}
+
+	if ( fixup_get_svalue(msg, gp, &tmp)!=0 )
+		return -1;
+	val->s = buf[n];
+	val->len = (tmp.len>MAX_BUF-1) ? MAX_BUF-1 : tmp.len ;
+	memcpy(val->s,tmp.s, val->len);
+	val->s[val->len] = 0;
+	return 0;
+}
+
 
 /*! \brief Return true if the string argument matches the pattern group parameter */
 static int w_pcre_match_group(struct sip_msg* _msg, char* _s1, char* _s2)
@@ -595,6 +616,7 @@ static int w_pcre_match_group(struct sip_msg* _msg, char* _s1, char* _s2)
 	str string;
 	int num_pcre;
 	int pcre_rc;
+	str group_id = { NULL, 0 };
 
 	/* Check if group matching feature is enabled */
 	if (file == NULL) {
@@ -607,10 +629,16 @@ static int w_pcre_match_group(struct sip_msg* _msg, char* _s1, char* _s2)
 		return -3;
 	}
 
-	if (_s2 == NULL) {
+	if (_s2) {
+		if (regex_get_var_svalue(_msg, (gparam_p)_s2, &group_id, 1)<0) {
+			LM_ERR("bogus Group parameter\n");
+			return -1;
+		}
+	}
+	if (group_id.s == NULL) {
 		num_pcre = 0;
 	} else {
-		num_pcre = (uint)(long)_s2;
+		sscanf(group_id.s,"%d",&num_pcre) ;
 	}
 
 	if (num_pcre >= *num_pcres) {
diff --git a/modules/rtpengine/rtpengine.c b/modules/rtpengine/rtpengine.c
index 4d2ea81..0aa894a 100644
--- a/modules/rtpengine/rtpengine.c
+++ b/modules/rtpengine/rtpengine.c
@@ -1066,6 +1066,8 @@ static int parse_flags(struct ng_flags_parse *ng_flags, struct sip_msg *msg, enu
 					bencode_list_add_string(ng_flags->direction, "internal");
 				else if (str_eq(&key, "external"))
 					bencode_list_add_string(ng_flags->direction, "external");
+				else if (str_eq(&key, "publicif"))
+					bencode_list_add_string(ng_flags->direction, "publicif");
 				else if (str_eq(&key, "RTP/AVPF"))
 					ng_flags->transport = 0x102;
 				else if (str_eq(&key, "RTP/SAVP"))
diff --git a/modules/sipmsgops/sipmsgops.c b/modules/sipmsgops/sipmsgops.c
index 5dbd40e..110b6f1 100644
--- a/modules/sipmsgops/sipmsgops.c
+++ b/modules/sipmsgops/sipmsgops.c
@@ -324,6 +324,7 @@ static inline int find_line_start(char *text, unsigned int text_len,
 }
 
 
+#if 0
 /* Filters multipart body by leaving out everything else except
  * first body part of given content type. */
 static int filter_body_f(struct sip_msg* msg, char* _content_type,
@@ -387,6 +388,116 @@ static int filter_body_f(struct sip_msg* msg, char* _content_type,
 	}
 	return -1;
 }
+#else
+static int check_multipart(struct sip_msg *msg)
+{
+	int mime;
+
+	/* the function search for and parses the Content-Type hdr */
+	mime = parse_content_type_hdr (msg);
+	if(mime<0) {
+		LM_ERR("failed to extract content type hdr\n");
+		return -1;
+	}
+	if(mime!=MIMETYPE(MULTIPART,MIXED)) return 0;
+	return 1;
+}
+
+/* Filters multipart/mixed body by leaving out everything else except
+ * first body part of given content type. */
+static int filter_body_f(struct sip_msg* msg, char* _content_type,
+			 char* ignored)
+{
+	char *start;
+	unsigned int len;
+	str *content_type, body;
+	str boundary = {0,0};
+
+	if ( get_body(msg,&body)!=0 || body.len==0) {
+		LM_DBG("message body has zero length\n");
+		return -1;
+	}
+	if (body.s == 0) {
+		LM_ERR("failed to get the message body\n");
+		return -1;
+	}
+	body.len = msg->len - (int)(body.s - msg->buf);
+	if (body.len == 0) {
+		LM_DBG("message body has zero length\n");
+		return -1;
+	}
+
+	if(check_multipart(msg)!=1) {
+		LM_WARN("body not multipart\n");
+		return -1;
+	}
+	if(get_boundary(msg, &boundary)!=0) {
+		return -1;
+	}
+	content_type = (str *)_content_type;
+	start = body.s;
+	len = body.len;
+
+	while (find_line_start("Content-Type: ", 14, &start, &len))
+	{
+		start = start + 14;
+		len = len - 14;
+		LM_DBG("line: [%.*s]\n", len, start);
+		if (len > content_type->len + 2) {
+			if (strncasecmp(start, content_type->s, content_type->len)== 0)
+			{
+				LM_DBG("found content type %.*s\n",
+					content_type->len, content_type->s);
+				start = start + content_type->len;
+				if ((*start != 13) || (*(start + 1) != 10))
+				{
+					LM_ERR("no CRLF found after content type\n");
+					goto err;
+				}
+				start = start + 2;
+				len = len - content_type->len - 2;
+				while ((len > 0) && ((*start == 13) || (*start == 10)))
+				{
+					len = len - 1;
+					start = start + 1;
+				}
+				if (del_lump(msg, body.s - msg->buf, start - body.s, 0)== 0)
+				{
+					LM_ERR("deleting lump <%.*s> failed\n",
+					(int)(start - body.s), body.s);
+					goto err;
+				}
+				if (find_line_start(boundary.s, boundary.len, &start,
+					&len))
+				{
+					/* we need to remove \r\n too */
+					if (del_lump(msg, (start-2) - msg->buf, len+2, 0) == 0)
+					{
+						LM_ERR("deleting lump <%.*s> failed\n", len, start);
+						goto err;
+					}
+					else
+					{
+						pkg_free(boundary.s);
+						return 1;
+					}
+				}
+				else
+				{
+					LM_ERR("boundary not found after content\n");
+					goto err;
+				}
+			}
+		} else {
+			goto err;
+		}
+	}
+ err:
+	if(boundary.s) pkg_free(boundary.s);
+	return -1;
+}
+
+#endif
 
 int get_pvs_header_value(struct sip_msg *msg, gparam_p gp, pv_value_p ret)
 {
@@ -432,6 +543,56 @@ int get_pvs_header_value(struct sip_msg *msg, gparam_p gp, pv_value_p ret)
 	return 0;
 }
 
+/**
+ * returns the boundary defined by the Content-Type
+ * header
+ */
+int get_boundary(struct sip_msg* msg, str* boundary)
+{
+	str params;
+	param_t *p, *list;
+	param_hooks_t hooks;
+
+	params.s = memchr(msg->content_type->body.s, ';',
+		msg->content_type->body.len);
+	if (params.s == NULL)
+	{
+		LM_INFO("Content-Type hdr has no params <%.*s>\n",
+				msg->content_type->body.len, msg->content_type->body.s);
+		return -1;
+	}
+	params.len = msg->content_type->body.len -
+		(params.s - msg->content_type->body.s);
+	if (parse_params(&params, CLASS_ANY, &hooks, &list) < 0)
+	{
+		LM_ERR("while parsing Content-Type params\n");
+		return -1;
+	}
+	boundary->s = NULL;
+	boundary->len = 0;
+	for (p = list; p; p = p->next) {
+		if ((p->name.len == 8)
+			&& (strncasecmp(p->name.s, "boundary", 8) == 0))
+		{
+			boundary->s = pkg_malloc(p->body.len + 2);
+			if (boundary->s == NULL)
+			{
+				free_params(list);
+				LM_ERR("no memory for boundary string\n");
+				return -1;
+			}
+			*(boundary->s) = '-';
+			*(boundary->s + 1) = '-';
+			memcpy(boundary->s + 2, p->body.s, p->body.len);
+			boundary->len = 2 + p->body.len;
+			LM_DBG("boundary is <%.*s>\n", boundary->len, boundary->s);
+			break;
+		}
+	}
+	free_params(list);
+	return 0;
+}
+
 static int hf_already_removed(struct sip_msg* msg, unsigned int offset,
 		unsigned int len, enum _hdr_types_t type)
 {
diff --git a/modules/topology_hiding/topo_hiding_logic.c b/modules/topology_hiding/topo_hiding_logic.c
index a1fbb65..97d09f9 100644
--- a/modules/topology_hiding/topo_hiding_logic.c
+++ b/modules/topology_hiding/topo_hiding_logic.c
@@ -34,6 +34,8 @@ extern str topo_hiding_prefix;
 extern str topo_hiding_seed;
 extern str topo_hiding_ct_encode_pw;
 extern str th_contact_encode_param;
+extern str topo_hiding_ct_hdr_name;
+extern str topo_hiding_ct_hdr_param_name;
 
 struct th_ct_params {
 	str param_name;
@@ -335,6 +337,9 @@ static int topo_dlg_replace_contact(struct sip_msg* msg, struct dlg_cell* dlg)
 	param_t *it;
 	str *rr_param;
 	struct lump* lump;
+	str dlg_ct_hdr_param_val = {0,0}; 
+	str dlg_ct_hdr_val = {0,0}; 
+
 
 	if(!msg->contact)
 	{
@@ -426,6 +431,15 @@ static int topo_dlg_replace_contact(struct sip_msg* msg, struct dlg_cell* dlg)
 		}
 	}
 
+	if(topo_hiding_ct_hdr_name.s && topo_hiding_ct_hdr_name.len>0) {
+		if (dlg_api.fetch_dlg_value(dlg, (str*)&topo_hiding_ct_hdr_name, &dlg_ct_hdr_val, 0) ) {
+			LM_DBG("No Contact hdr param dlg value set for dialog <%.*s>\n",
+				((str*)&topo_hiding_ct_hdr_name)->len, ((str*)&topo_hiding_ct_hdr_name)->s);
+		} else {
+			suffix_len += dlg_ct_hdr_val.len + 1; /* extra ';' */
+		}
+	}
+
 	suffix = pkg_malloc(suffix_len);
 	if (!suffix) {
 		LM_ERR("no more pkg\n");
@@ -440,6 +454,13 @@ static int topo_dlg_replace_contact(struct sip_msg* msg, struct dlg_cell* dlg)
 
 	rr_param = dlg_api.get_rr_param();
 	p_init = p = suffix;
+
+	if(dlg_ct_hdr_val.s && dlg_ct_hdr_val.len>0) {
+		*p++ = ';';
+		memcpy(p,dlg_ct_hdr_val.s,dlg_ct_hdr_val.len);
+		p += dlg_ct_hdr_val.len ;
+	}
+
 	*p++ = ';';
 	memcpy(p,rr_param->s,rr_param->len);
 	p+=rr_param->len;
@@ -476,6 +497,22 @@ static int topo_dlg_replace_contact(struct sip_msg* msg, struct dlg_cell* dlg)
 	}
 
 	*p++ = '>';
+
+	if(topo_hiding_ct_hdr_param_name.s && topo_hiding_ct_hdr_param_name.len>0) {
+		if (dlg_api.fetch_dlg_value(dlg, (str*)&topo_hiding_ct_hdr_param_name, &dlg_ct_hdr_param_val, 0) ) {
+			LM_DBG("No Contact hdr param dlg value set for dialog <%.*s>\n",
+				((str*)&topo_hiding_ct_hdr_param_name)->len, ((str*)&topo_hiding_ct_hdr_param_name)->s);
+		} else {
+			suffix_len += dlg_ct_hdr_param_val.len + 1; /* extra ';' */
+		}
+	}
+ 
+	if(dlg_ct_hdr_param_val.s && dlg_ct_hdr_param_val.len>0) {
+		*p++ = ';';
+		memcpy(p,dlg_ct_hdr_param_val.s,dlg_ct_hdr_param_val.len);
+		p += dlg_ct_hdr_param_val.len ;
+	}
+
 	if (th_hdr_param_list) {
 		if ( parse_contact(msg->contact)<0 ||
 			((contact_body_t *)msg->contact->parsed)->contacts==NULL ||
diff --git a/modules/topology_hiding/topology_hiding.c b/modules/topology_hiding/topology_hiding.c
index bf7a990..aacf7de 100644
--- a/modules/topology_hiding/topology_hiding.c
+++ b/modules/topology_hiding/topology_hiding.c
@@ -36,6 +36,8 @@ struct dlg_binds dlg_api;
 int force_dialog = 0;
 str topo_hiding_ct_params = {0,0};
 str topo_hiding_ct_hdr_params = {0,0};
+str topo_hiding_ct_hdr_name = {0,0};
+str topo_hiding_ct_hdr_param_name = {0,0};
 str topo_hiding_prefix = str_init("DLGCH_");
 str topo_hiding_seed = str_init("OpenSIPS");
 str topo_hiding_ct_encode_pw = str_init("ToPoCtPaSS");
@@ -69,6 +71,8 @@ static param_export_t params[] = {
 	{ "th_callid_prefix",            STR_PARAM, &topo_hiding_prefix.s        },
 	{ "th_contact_encode_passwd",    STR_PARAM, &topo_hiding_ct_encode_pw.s  },
 	{ "th_contact_encode_param",     STR_PARAM, &th_contact_encode_param.s   },
+	{ "th_dlg_contact_uri_params",   STR_PARAM, &topo_hiding_ct_hdr_name.s },
+	{ "th_dlg_contact_params",       STR_PARAM, &topo_hiding_ct_hdr_param_name.s },
 	{0, 0, 0}
 };
 
@@ -91,6 +95,7 @@ static module_dependency_t *get_deps_dialog(param_export_t *param)
 static dep_export_t deps = {
 	{ /* OpenSIPS module dependencies */
 		{ MOD_TYPE_DEFAULT, "tm", DEP_ABORT },
+		{ MOD_TYPE_DEFAULT, "dialog", DEP_ABORT },
 		{ MOD_TYPE_NULL, NULL, 0 },
 	},
 	{ /* modparam dependencies */
@@ -134,6 +139,13 @@ static int mod_init(void)
 		topo_hiding_ct_hdr_params.len = strlen(topo_hiding_ct_hdr_params.s);
 		topo_parse_passed_hdr_ct_params(&topo_hiding_ct_hdr_params);
 	}
+	if(topo_hiding_ct_hdr_name.s) {
+		topo_hiding_ct_hdr_name.len = strlen(topo_hiding_ct_hdr_name.s) ;
+	}
+	if(topo_hiding_ct_hdr_param_name.s) {
+		topo_hiding_ct_hdr_param_name.len = strlen(topo_hiding_ct_hdr_param_name.s) ;
+	}
+
 
 	/* loading dependencies */
 	if (load_tm_api(&tm_api)!=0) {
diff --git a/modules/uac_subclient/Makefile b/modules/uac_subclient/Makefile
new file mode 100644
index 0000000..558175f
--- /dev/null
+++ b/modules/uac_subclient/Makefile
@@ -0,0 +1,10 @@
+# $Id: Makefile 806 2006-04-14 11:00:10Z bogdan_iancu $
+#
+# WARNING: do not run this directly, it should be run by the master Makefile
+
+include ../../Makefile.defs
+auto_gen=
+NAME=uac_subclient.so
+LIBS= 
+
+include ../../Makefile.modules
diff --git a/modules/uac_subclient/README b/modules/uac_subclient/README
new file mode 100644
index 0000000..7658606
--- /dev/null
+++ b/modules/uac_subclient/README
@@ -0,0 +1,341 @@
+UAC Registrant Module
+
+Ovidiu Sas
+
+   <osas@voipembedded.com>
+
+Edited by
+
+Ovidiu Sas
+
+   <osas@voipembedded.com>
+
+   Copyright © 2011-2014 VoIP Embedded, Inc.
+   Revision History
+   Revision $Revision$ $Date$
+     __________________________________________________________
+
+   Table of Contents
+
+   1. Admin Guide
+
+        1.1. Overview
+        1.2. Dependencies
+
+              1.2.1. OpenSIPS Modules
+              1.2.2. External Libraries or Applications
+
+        1.3. Exported Parameters
+
+              1.3.1. hash_size (integer)
+              1.3.2. timer_interval (integer)
+              1.3.3. db_url (string)
+              1.3.4. table_name (string)
+              1.3.5. registrar_column (string)
+              1.3.6. proxy_column (string)
+              1.3.7. aor_column (string)
+              1.3.8. third_party_registrant_column (string)
+              1.3.9. username_column (string)
+              1.3.10. password_column (string)
+              1.3.11. binding_URI_column (string)
+              1.3.12. binding_params_column (string)
+              1.3.13. expiry_column (string)
+              1.3.14. forced_socket_column (string)
+
+        1.4. Exported Functions
+        1.5. Exported MI Functions
+
+              1.5.1. reg_list
+              1.5.2. reg_reload
+
+   List of Examples
+
+   1.1. Set hash_size parameter
+   1.2. Set timer_interval parameter
+   1.3. Set “db_url” parameter
+   1.4. Set “table_name” parameter
+   1.5. Set “registrar_column” parameter
+   1.6. Set “proxy_column” parameter
+   1.7. Set “aor_column” parameter
+   1.8. Set “third_party_registrant_column” parameter
+   1.9. Set “username_column” parameter
+   1.10. Set “password_column” parameter
+   1.11. Set “binding_URI_column” parameter
+   1.12. Set “binding_params_column” parameter
+   1.13. Set “expiry_column” parameter
+   1.14. Set “forced_socket_column” parameter
+
+Chapter 1. Admin Guide
+
+1.1. Overview
+
+   The module enable OpenSIPS to register itself on a remote SIP
+   registrar.
+
+   At startup, the registrant records are loaded into a hash table
+   in memory and a timer is started. The hash index is computed
+   over the AOR field.
+
+   The timer interval for checking records in a hash bucket is
+   computed by dividing the timer_interval module param by the
+   number of hash buckets. When the timer fires for the first
+   time, the first hash bucket will be checked and REGISTERs will
+   be sent out for each record that is found. On the next timeout
+   fire, the second hash bucket will be checked and so on. If the
+   configured timer_interval module param is lower then the number
+   of buckets, the module will fail to start.
+
+   Example: setting the timer_interval module to 8 with a
+   hash_size of 2, will result in having 4 hash buckets (2^2=4)
+   and buckets will be checked one by one every 2s (8/4=2).
+
+   Each registrant has it's own state. Registranr's status can be
+   inspected via "reg_list" MI comand.
+
+   UAC registrant states:
+     * 0 - NOT_REGISTERED_STATE - the initial state (no REGISTER
+       has been sent out yet);
+     * 1 - REGISTERING_STATE - waiting for a reply from the
+       registrar after a REGISTER without authentication header
+       was sent;
+     * 2 - AUTHENTICATING_STATE - waiting for a reply from the
+       registrar after a REGISTER with authentication header was
+       sent;
+     * 3 - REGISTERED_STATE - the uac is successfully registered;
+     * 4 - REGISTER_TIMEOUT_STATE : no reply received from the
+       registrar;
+     * 5 - INTERNAL_ERROR_STATE - some errors were
+       found/encountered during the processing of a reply;
+     * 6 - WRONG_CREDENTIALS_STATE - credentials rejected by the
+       registrar;
+     * 7 - REGISTRAR_ERROR_STATE - error reply received from the
+       registrar;
+
+1.2. Dependencies
+
+1.2.1. OpenSIPS Modules
+
+   The following modules must be loaded before this module:
+     * uac_auth - UAC authentication module
+
+1.2.2. External Libraries or Applications
+
+   None.
+
+1.3. Exported Parameters
+
+1.3.1. hash_size (integer)
+
+   The size of the hash table internally used to keep the
+   registrants. A larger table distributes better the registration
+   load in time but consumes more memory. The hash size is a power
+   of number two.
+
+   Default value is 1.
+
+   Example 1.1. Set hash_size parameter
+...
+modparam("uac_registrant", "hash_size", 2)
+...
+
+1.3.2. timer_interval (integer)
+
+   Defines the periodic timer for checking the registrations
+   status.
+
+   Default value is 100.
+
+   Example 1.2. Set timer_interval parameter
+...
+modparam("uac_registrant", "timer_interval", 120)
+...
+
+1.3.3. db_url (string)
+
+   Database where to load the registrants from.
+
+   Default value is “NULL” (use default DB URL from core).
+
+   Example 1.3. Set “db_url” parameter
+...
+modparam("uac_registrant", "db_url", "mysql://user:passw@localhost/datab
+ase")
+...
+
+1.3.4. table_name (string)
+
+   The database table that holds the registrant records.
+
+   Default value is “registrant”.
+
+   Example 1.4. Set “table_name” parameter
+...
+modparam("uac_registrant", "table_name", "my_registrant")
+...
+
+1.3.5. registrar_column (string)
+
+   The column's name in the database storing the URI pointing to
+   the remote registrar (mandatory field). OpenSIPS expects a
+   valid URI.
+
+   Default value is “registrar”.
+
+   Example 1.5. Set “registrar_column” parameter
+...
+modparam("uac_registrant", "registrar_column", "registrant_uri")
+...
+
+1.3.6. proxy_column (string)
+
+   The column's name in the database storing the URI pointing to
+   the outbond proxy (not mandatory field). An empty or NULL value
+   means no outbound proxy, otherwise OpenSIPS expects a valid
+   URI.
+
+   Default value is “proxy”.
+
+   Example 1.6. Set “proxy_column” parameter
+...
+modparam("uac_registrant", "proxy_column", "proxy_uri")
+...
+
+1.3.7. aor_column (string)
+
+   The column's name in the database storing the URI defining the
+   address of record (mandatory field). The URI stored here will
+   be used in the To URI of the REGISTER. OpenSIPS expects a valid
+   URI.
+
+   Default value is “aor”.
+
+   Example 1.7. Set “aor_column” parameter
+...
+modparam("uac_registrant", "aor_column", "to_uri")
+...
+
+1.3.8. third_party_registrant_column (string)
+
+   The column's name in the database storing the URI defining the
+   third party registrant (not mandatory field). The URI stored
+   here will be used in the From URI of the REGISTER. An empty or
+   NULL value means no third party registration (the From URI will
+   be identical to To URI), otherwise OpenSIPS expects a valid
+   URI.
+
+   Default value is “third_party_registrant”.
+
+   Example 1.8. Set “third_party_registrant_column” parameter
+...
+modparam("uac_registrant", "third_party_registrant_column", "from_uri")
+...
+
+1.3.9. username_column (string)
+
+   The column's name in the database storing the username for
+   authentication (mandatory if the registrar requires
+   authentication).
+
+   Default value is “username”.
+
+   Example 1.9. Set “username_column” parameter
+...
+modparam("uac_registrant", "username_column", "auth_username")
+...
+
+1.3.10. password_column (string)
+
+   The column's name in the database storing the password for
+   authentication (mandatory if the registrar requires
+   authntication).
+
+   Default value is “password”.
+
+   Example 1.10. Set “password_column” parameter
+...
+modparam("uac_registrant", "password_column", "auth_passowrd")
+...
+
+1.3.11. binding_URI_column (string)
+
+   The column's name in the database storing the binding URI in
+   REGISTER (mandatory field). The URI stored here will be used in
+   the Contact URI of the REGISTER. OpenSIPS expects a valid URI.
+
+   Default value is “binding_URI”.
+
+   Example 1.11. Set “binding_URI_column” parameter
+...
+modparam("uac_registrant", "binding_URI_column", "contact_uri")
+...
+
+1.3.12. binding_params_column (string)
+
+   The column's name in the database storing the binding params in
+   REGISTER (not mandatory field). If not NULL or not empty, the
+   string stored here will be added as params to the Contact URI
+   in REGISTER (it MUST start with “;”. There is no validation on
+   the string stored here.
+
+   Default value is “binding_params”.
+
+   Example 1.12. Set “binding_params_column” parameter
+...
+modparam("uac_registrant", "binding_params_column", "contact_params")
+...
+
+1.3.13. expiry_column (string)
+
+   The column's name in the database storing the expiration time
+   (not mandatory).
+
+   Default value is “expiry”.
+
+   Example 1.13. Set “expiry_column” parameter
+...
+modparam("uac_registrant", "expiry_column", "registration_timeout")
+...
+
+1.3.14. forced_socket_column (string)
+
+   The column's name in the database storing the socket for
+   sending the REGISTER (not mandatory). If a forced socket is
+   provided, the socket MUST be explicitely set as a global
+   listening socket in the config (see “listen” core parameter).
+
+   Default value is “forced_socket”.
+
+   Example 1.14. Set “forced_socket_column” parameter
+...
+modparam("uac_registrant", "forced_socket_column", "fs")
+...
+
+1.4. Exported Functions
+
+   None to be used in configuration file.
+
+1.5. Exported MI Functions
+
+1.5.1. reg_list
+
+   Lists the registrant records and their status.
+
+   Name: reg_list
+
+   Parameters: none
+
+   MI FIFO Command Format:
+:reg_list:_reply_fifo_file_
+_empty_line_
+
+1.5.2. reg_reload
+
+   Reloads the registrant records from the database.
+
+   Name: reg_reload
+
+   Parameters: none
+
+   MI FIFO Command Format:
+:reg_reload:_reply_fifo_file_
+_empty_line_
diff --git a/modules/uac_subclient/sub_db_handler.c b/modules/uac_subclient/sub_db_handler.c
new file mode 100644
index 0000000..db61855
--- /dev/null
+++ b/modules/uac_subclient/sub_db_handler.c
@@ -0,0 +1,422 @@
+/*
+ * sub_db_handler module
+ *
+ * Copyright (C) 2011 VoIP Embedded, Inc.
+ *
+ * This file is part of opensips, a free SIP server.
+ *
+ * opensips is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ * opensips is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
+ *
+ * History:
+ * --------
+ *  2011-12-16  initial version (Ovidiu Sas)
+ */
+
+#include "../../dprint.h"
+#include "../../db/db.h"
+#include "../../str.h"
+
+#include "sub_db_handler.h"
+
+str subserver_column = str_init(SUBSERVER_COL);
+str proxy_column = str_init(PROXY_COL);
+str aor_column = str_init(AOR_COL);
+str third_party_subclient_column = str_init(THIRD_PARTY_SUBCLIENT_COL);
+str username_column = str_init(USERNAME_COL);
+str password_column = str_init(PASSWORD_COL);
+str binding_URI_column = str_init(BINDING_URI_COL);
+str binding_params_column = str_init(BINDING_PARAMS_COL);
+str expiry_column = str_init(EXPIRY_COL);
+str forced_socket_column = str_init(FORCED_SOCKET_COL);
+str extra_headers_column = str_init(EXTRA_HEADERS_COL);
+
+str sub_table_name = str_init(SUB_TABLE_NAME);
+
+static db_con_t *sub_db_handle = NULL;
+static db_func_t sub_dbf;
+
+
+int connect_sub_db(const str *db_url)
+{
+	if (sub_db_handle) {
+		LM_CRIT("BUG - db connection found already open\n");
+		return -1;
+	}
+	if ((sub_db_handle = sub_dbf.init(db_url)) == NULL)
+		return -1;
+	return 0;
+}
+
+
+static int use_sub_table(void)
+{
+	if(!sub_db_handle){
+		LM_ERR("invalid database handle\n");
+		return -1;
+	}
+	sub_dbf.use_table(sub_db_handle, &sub_table_name);
+	return 0;
+}
+
+
+int load_sub_info_from_db(unsigned int plist)
+{
+	db_res_t * res = NULL;
+	db_val_t * values;
+	db_row_t * rows;
+	int i, nr_rows, ret;
+	unsigned int n_result_cols = 0;
+	unsigned int subserver_col;
+	unsigned int proxy_col;
+	unsigned int aor_col;
+	unsigned int third_party_subclient_col;
+	unsigned int username_col;
+	unsigned int password_col;
+	unsigned int binding_URI_col;
+	unsigned int binding_params_col;
+	unsigned int expiry_col;
+	unsigned int forced_socket_col;
+	unsigned int extra_headers_col;
+	db_key_t q_cols[SUB_TABLE_TOTAL_COL_NO];
+
+	char *p = NULL;
+	int len = 0;
+	str now = {NULL, 0};
+	struct sip_uri uri;
+	str forced_socket, host;
+	int port, proto;
+	uac_sub_map_t uac_param;
+
+	p = int2str((unsigned long)(time(0)), &len);
+	if (p && len>0) {
+		now.s = (char *)pkg_malloc(len);
+		if(now.s) {
+			memcpy(now.s, p, len); now.len = len;
+		} else {
+			LM_ERR("oom\n"); return -1;
+		}
+	}
+
+	if(use_sub_table()) return -1;
+
+	q_cols[subserver_col = n_result_cols++] = &subserver_column;
+	q_cols[proxy_col = n_result_cols++] = &proxy_column;
+	q_cols[aor_col = n_result_cols++] = &aor_column;
+	q_cols[third_party_subclient_col = n_result_cols++] =
+					&third_party_subclient_column;
+	q_cols[username_col = n_result_cols++] = &username_column;
+	q_cols[password_col = n_result_cols++] = &password_column;
+	q_cols[binding_URI_col = n_result_cols++] = &binding_URI_column;
+	q_cols[binding_params_col = n_result_cols++] = &binding_params_column;
+	q_cols[expiry_col = n_result_cols++] = &expiry_column;
+	q_cols[forced_socket_col = n_result_cols++] = &forced_socket_column;
+	q_cols[extra_headers_col = n_result_cols++] = &extra_headers_column;
+
+	/* select the whole tabel and all the columns */
+	if (DB_CAPABILITY(sub_dbf, DB_CAP_FETCH)) {
+		if(sub_dbf.query(sub_db_handle, 0, 0, 0, q_cols, 0,
+				SUB_TABLE_TOTAL_COL_NO, 0, 0) < 0) {
+			LM_ERR("Error while querying (fetch) database\n");
+			return -1;
+		}
+		if(sub_dbf.fetch_result(sub_db_handle, &res, SUB_FETCH_SIZE)<0){
+			LM_ERR("fetching rows failed\n");
+			return -1;
+		}
+	} else {
+		if(sub_dbf.query(sub_db_handle, 0, 0, 0, q_cols, 0,
+				SUB_TABLE_TOTAL_COL_NO, 0, &res) < 0) {
+			LM_ERR("Error while querying database\n");
+			return -1;
+		}
+	}
+
+	nr_rows = RES_ROW_N(res);
+
+	do {
+		LM_INFO("loading [%i] records from db\n", nr_rows);
+		rows = RES_ROWS(res);
+		/* for every row/record */
+		for(i=0; i<nr_rows; i++){
+			values = ROW_VALUES(rows + i);
+			if (VAL_NULL(values+subserver_col) ||
+				VAL_NULL(values+aor_col) ||
+				VAL_NULL(values+binding_URI_col)) {
+				LM_ERR("columns [%.*s] or/and [%.*s] or/and [%.*s]"
+					" cannot be null -> skipping\n",
+					subserver_column.len, subserver_column.s,
+					aor_column.len, aor_column.s,
+					binding_URI_column.len, binding_URI_column.s);
+				continue;
+			}
+
+			memset(&uac_param, 0, sizeof(uac_sub_map_t));
+
+			/* Get the subserver (mandatory parameter) */
+			uac_param.subserver_uri.s =
+				(char*)values[subserver_col].val.string_val;
+			if (uac_param.subserver_uri.s)
+				uac_param.subserver_uri.len =
+					strlen(uac_param.subserver_uri.s);
+			else {
+				LM_ERR("ignoring empty subserver\n");
+				continue;
+			}
+			if (parse_uri(uac_param.subserver_uri.s,
+					uac_param.subserver_uri.len, &uri)<0) {
+				LM_ERR("cannot parse subserver uri [%.*s]\n",
+					uac_param.subserver_uri.len,
+					uac_param.subserver_uri.s);
+				continue;
+			}
+#if 0
+			if (uri.user.s && uri.user.len) {
+				LM_ERR("subclient uri must not have user [%.*s]\n",
+					uri.user.len, uri.user.s);
+				continue;
+			}
+#endif
+
+			/* Get the proxy */
+			uac_param.proxy_uri.s =
+				(char*)values[proxy_col].val.string_val;
+			if (uac_param.proxy_uri.s)
+				uac_param.proxy_uri.len =
+					strlen(uac_param.proxy_uri.s);
+			if (uac_param.proxy_uri.len) {
+				if (parse_uri(uac_param.proxy_uri.s,
+						uac_param.proxy_uri.len, &uri)<0) {
+					LM_ERR("cannot parse proxy uri [%.*s]\n",
+						uac_param.proxy_uri.len,
+						uac_param.proxy_uri.s);
+					continue;
+				}
+				if (uri.user.s && uri.user.len) {
+					LM_ERR("proxy uri must not have user [%.*s]\n",
+						uri.user.len, uri.user.s);
+					continue;
+				}
+			} else {
+				uac_param.proxy_uri.s = NULL;
+			}
+
+			/* Get the AOR (mandatory parameter) */
+			uac_param.to_uri.s =
+				(char*)values[aor_col].val.string_val;
+			if (uac_param.to_uri.s)
+				uac_param.to_uri.len = strlen(uac_param.to_uri.s);
+			else {
+				LM_ERR("ignoring empty AOR\n");
+				continue;
+			}
+			/*
+			if (uac_param.to_uri.s[0]=='<' && uac_param.to_uri.s[uac_param.to_uri.len-1]=='>') {
+				if (parse_uri(uac_param.to_uri.s+1,uac_param.to_uri.len-2,&uri)<0) {
+					LM_ERR("cannot parse aor uri [%.*s]\n",
+						uac_param.to_uri.len, uac_param.to_uri.s);
+					continue;
+				}
+			} else 
+			*/
+			if (parse_uri(uac_param.to_uri.s,uac_param.to_uri.len,&uri)<0) {
+				LM_ERR("cannot parse aor uri [%.*s]\n",
+					uac_param.to_uri.len, uac_param.to_uri.s);
+				continue;
+			}
+			uac_param.hash_code =
+				core_hash(&uac_param.to_uri, NULL, sub_hsize);
+
+			/* Get the third party subclient */
+			uac_param.from_uri.s =
+				(char*)values[third_party_subclient_col].val.string_val;
+			if (uac_param.from_uri.s)
+				uac_param.from_uri.len = strlen(uac_param.from_uri.s);
+			if (uac_param.from_uri.len) {
+				if (parse_uri(uac_param.from_uri.s,
+						uac_param.from_uri.len, &uri)<0) {
+					LM_ERR("cannot parse third party subclient"
+						" uri [%.*s]\n",
+						uac_param.from_uri.len,
+						uac_param.from_uri.s);
+					continue;
+				}
+			} else {
+				uac_param.from_uri.s = NULL;
+			}
+
+			/* Get the binding (manadatory parameter) */
+			uac_param.contact_uri.s =
+				(char*)values[binding_URI_col].val.string_val;
+			if (uac_param.contact_uri.s)
+				uac_param.contact_uri.len =
+					strlen(uac_param.contact_uri.s);
+			else {
+				LM_ERR("ignoring empty binding\n");
+				continue;
+			}
+			if (parse_uri(uac_param.contact_uri.s,
+					uac_param.contact_uri.len, &uri)<0) {
+				LM_ERR("cannot parse contact uri [%.*s]\n",
+					uac_param.contact_uri.len,
+					uac_param.contact_uri.s);
+				continue;
+			}
+
+			/* Get the authentication user */
+			uac_param.auth_user.s =
+				(char*)values[username_col].val.string_val;
+			if (uac_param.auth_user.s)
+				uac_param.auth_user.len = strlen(uac_param.auth_user.s);
+			if (uac_param.auth_user.len == 0) uac_param.auth_user.s = NULL;
+
+			/* Get the authentication password */
+			uac_param.auth_password.s =
+				(char*)values[password_col].val.string_val;
+			if (uac_param.auth_password.s)
+				uac_param.auth_password.len =
+					strlen(uac_param.auth_password.s);
+			if (uac_param.auth_password.len == 0)
+				uac_param.auth_password.s = NULL;
+
+			/* Get the binding params */
+			uac_param.contact_params.s =
+				(char*)values[binding_params_col].val.string_val;
+			if (uac_param.contact_params.s)
+				uac_param.contact_params.len =
+					strlen(uac_param.contact_params.s);
+			if (uac_param.contact_params.len == 0)
+				uac_param.contact_params.s = NULL;
+
+			/* Get the expiration param */
+			uac_param.expires = values[expiry_col].val.int_val;
+			if (uac_param.expires <= timer_interval) {
+				LM_ERR("Please decrease timer_interval=[%u]"
+					" - requested expires=[%u] to small for AOR=[%.*s]\n",
+					timer_interval, uac_param.expires,
+					uac_param.to_uri.len, uac_param.to_uri.s);
+				continue;
+			}
+
+			/* Get the socket */
+			if (values[forced_socket_col].val.string_val &&
+				(forced_socket.s = (char*)values[forced_socket_col].val.string_val)) {
+				if((forced_socket.len = strlen(forced_socket.s))){
+					if (parse_phostport(forced_socket.s,
+							forced_socket.len,
+							&host.s, &host.len,
+							&port, &proto)<0) {
+						LM_ERR("cannot parse forced socket [%.*s]\n",
+							forced_socket.len, forced_socket.s);
+						continue;
+					}
+					uac_param.send_sock = grep_sock_info(&host,
+								(unsigned short) port,
+								(unsigned short) proto);
+					if (uac_param.send_sock==NULL) {
+						LM_ERR("invalid forced socket [%.*s]\n",
+							forced_socket.len, forced_socket.s);
+						continue;
+					}
+				}
+			}
+
+			uac_param.extra_headers.s =
+				(char*)values[extra_headers_col].val.string_val;
+			if (uac_param.extra_headers.s)
+				uac_param.extra_headers.len =
+					strlen(uac_param.extra_headers.s);
+			if (uac_param.extra_headers.len == 0)
+				uac_param.extra_headers.s = NULL;
+
+			LM_DBG("subserver=[%.*s] AOR=[%.*s] auth_user=[%.*s] "
+				"password=[%.*s] expire=[%d] proxy=[%.*s] "
+				"contact=[%.*s] third_party=[%.*s] "
+                                "extra_headers=[%.*s]\n",
+				uac_param.subserver_uri.len, uac_param.subserver_uri.s,
+				uac_param.to_uri.len, uac_param.to_uri.s,
+				uac_param.auth_user.len, uac_param.auth_user.s,
+				uac_param.auth_password.len, uac_param.auth_password.s,
+				uac_param.expires,
+				uac_param.proxy_uri.len, uac_param.proxy_uri.s,
+				uac_param.contact_uri.len, uac_param.contact_uri.s,
+				uac_param.from_uri.len, uac_param.from_uri.s,
+				uac_param.extra_headers.len, uac_param.extra_headers.s);
+			lock_get(&sub_htable[uac_param.hash_code].lock);
+			ret = add_record(&uac_param, &now, plist);
+			lock_release(&sub_htable[uac_param.hash_code].lock);
+			if(ret<0) {
+				LM_ERR("can't load subclient\n");
+				continue;
+			}
+		}
+
+		/* any more data to be fetched ?*/
+		if (DB_CAPABILITY(sub_dbf, DB_CAP_FETCH)) {
+			if (sub_dbf.fetch_result(sub_db_handle, &res, SUB_FETCH_SIZE)<0) {
+				LM_ERR("fetching more rows failed\n");
+				goto error;
+			}
+			nr_rows = RES_ROW_N(res);
+		} else {
+			nr_rows = 0;
+		}
+	}while (nr_rows>0);
+
+	sub_dbf.free_result(sub_db_handle, res);
+	if (now.s) pkg_free(now.s);
+	return 0;
+error:
+	sub_dbf.free_result(sub_db_handle, res);
+	if (now.s) pkg_free(now.s);
+	return -1;
+}
+
+
+int init_sub_db(const str *db_url)
+{
+	/* Find a database module */
+	if (db_bind_mod(db_url, &sub_dbf) < 0) {
+		LM_ERR("Unable to bind to a database driver\n");
+		return -1;
+	}
+	if (connect_sub_db(db_url)!=0){
+		LM_ERR("unable to connect to the database\n");
+		return -1;
+	}
+	if(db_check_table_version(&sub_dbf, sub_db_handle,
+			&sub_table_name, SUB_TABLE_VERSION) < 0) {
+		LM_ERR("error during table version check.\n");
+		return -1;
+	}
+	/* Load subclients into the primary list */
+	if(load_sub_info_from_db(0) !=0){
+		LM_ERR("unable to load the subclient data\n");
+		return -1;
+	}
+
+	sub_dbf.close(sub_db_handle);
+	sub_db_handle = NULL;
+
+	return 0;
+}
+
+
+void destroy_sub_db(void)
+{
+	if (sub_db_handle) {
+		sub_dbf.close(sub_db_handle);
+		sub_db_handle = NULL;
+	}
+}
diff --git a/modules/uac_subclient/sub_db_handler.h b/modules/uac_subclient/sub_db_handler.h
new file mode 100644
index 0000000..4f44539
--- /dev/null
+++ b/modules/uac_subclient/sub_db_handler.h
@@ -0,0 +1,76 @@
+/*
+ * sub_db_handler module
+ *
+ * Copyright (C) 2011 VoIP Embedded, Inc.
+ *
+ * This file is part of opensips, a free SIP server.
+ *
+ * opensips is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ * opensips is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
+ *
+ * History:
+ * --------
+ * 2011-12-16  initial version (Ovidiu Sas)
+ */
+
+#ifndef SUB_DB_HANDLER
+#define SUB_DB_HANDLER
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "sub_records.h"
+
+
+#define SUBSERVER_COL			"subserver"
+#define PROXY_COL			"proxy"
+#define AOR_COL				"aor"
+#define THIRD_PARTY_SUBCLIENT_COL	"third_party_subclient"
+#define USERNAME_COL			"username"
+#define PASSWORD_COL			"password"
+#define BINDING_URI_COL			"binding_URI"
+#define BINDING_PARAMS_COL		"binding_params"
+#define EXPIRY_COL			"expiry"
+#define FORCED_SOCKET_COL		"forced_socket"
+#define EXTRA_HEADERS_COL		"extra_headers"
+
+#define SUB_TABLE_NAME			"subclient"
+
+#define SUB_TABLE_VERSION		1
+
+#define SUB_TABLE_TOTAL_COL_NO		11
+
+#define SUB_FETCH_SIZE			128
+
+extern str subserver_column;
+extern str proxy_column;
+extern str aor_column;
+extern str third_party_subclient_column;
+extern str username_column;
+extern str password_column;
+extern str binding_URI_column;
+extern str binding_params_column;
+extern str expiry_column;
+extern str forced_socket_column;
+
+extern str sub_table_name;
+
+extern unsigned int timer_interval;
+
+int init_sub_db(const str *db_url);
+int connect_sub_db(const str *db_url);
+int load_sub_info_from_db(unsigned int plist);
+void destroy_sub_db(void);
+
+#endif
diff --git a/modules/uac_subclient/sub_records.c b/modules/uac_subclient/sub_records.c
new file mode 100644
index 0000000..a6606eb
--- /dev/null
+++ b/modules/uac_subclient/sub_records.c
@@ -0,0 +1,286 @@
+/*
+ * subclient module
+ *
+ * Copyright (C) 2011 VoIP Embedded Inc.
+ *
+ * This file is part of opensips, a free SIP server.
+ *
+ * opensips is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ * opensips is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
+ *
+ * History:
+ * --------
+ *  2011-02-11  initial version (Ovidiu Sas)
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "sub_records.h"
+
+extern unsigned int default_expires;
+extern const str uac_sub_state[];
+
+static char call_id_ftag_buf[MD5_LEN];
+
+
+void sub_print_record(sub_record_t *rec) {
+	LM_DBG("checking uac=[%p] state=[%d][%.*s] expires=[%d]"
+			" last_subscribe_sent=[%d] subistration_timeout=[%d]"
+			" auth_user[%p][%d]->[%.*s] auth_password=[%p][%d]->[%.*s] "
+			" extra_headers=[%p][%d]->[%.*s] sock=[%p]\n",
+		rec, rec->state,
+		uac_sub_state[rec->state].len, uac_sub_state[rec->state].s, rec->expires,
+		(unsigned int)rec->last_subscribe_sent, (unsigned int)rec->subistration_timeout,
+		rec->auth_user.s, rec->auth_user.len, rec->auth_user.len, rec->auth_user.s,
+		rec->auth_password.s, rec->auth_password.len, 
+		rec->auth_password.len, rec->auth_password.s, 
+		rec->extra_headers.s, rec->extra_headers.len,
+		rec->extra_headers.len, rec->extra_headers.s, rec->td.send_sock);
+	LM_DBG("    RURI=[%p][%d]->[%.*s]\n", rec->td.rem_target.s, rec->td.rem_target.len,
+			rec->td.rem_target.len, rec->td.rem_target.s);
+	LM_DBG("      To=[%p][%d]->[%.*s]\n", rec->td.rem_uri.s, rec->td.rem_uri.len,
+			rec->td.rem_uri.len, rec->td.rem_uri.s);
+	LM_DBG("    From=[%p][%d]->[%.*s] tag=[%p][%d]->[%.*s]\n",
+			rec->td.loc_uri.s, rec->td.loc_uri.len,
+			rec->td.loc_uri.len, rec->td.loc_uri.s,
+			rec->td.id.loc_tag.s, rec->td.id.loc_tag.len,
+			rec->td.id.loc_tag.len, rec->td.id.loc_tag.s);
+	LM_DBG(" Call-Id=[%p][%d]->[%.*s]\n", rec->td.id.call_id.s, rec->td.id.call_id.len,
+			rec->td.id.call_id.len, rec->td.id.call_id.s);
+	LM_DBG(" Contact=[%p][%d]->[%.*s] [%p][%d]->[%.*s]\n",
+			rec->contact_uri.s, rec->contact_uri.len,
+			rec->contact_uri.len, rec->contact_uri.s,
+			rec->contact_params.s, rec->contact_params.len,
+			rec->contact_params.len, rec->contact_params.s);
+	if (rec->td.obp.s && rec->td.obp.len) {
+		LM_DBG(" Proxy=[%p][%d]->[%.*s]\n",
+			rec->td.obp.s, rec->td.obp.len, rec->td.obp.len, rec->td.obp.s);
+	}
+
+	return;
+}
+
+
+static void gen_call_id_ftag(str *aor, str *now, str *call_id_ftag)
+{
+	int i = 0;
+	str src[2];
+
+	call_id_ftag->len = MD5_LEN;
+	call_id_ftag->s = call_id_ftag_buf;
+
+	src[i++] = *aor;
+	if(now->s && now->len)
+		src[i++] = *now;
+
+	MD5StringArray(call_id_ftag->s, src, i);
+	return;
+}
+
+
+void new_call_id_ftag_4_record(sub_record_t *rec, str *now)
+{
+	str call_id_ftag;
+	char *p = (char *)(rec + 1);
+
+	/* generate the new Call-ID and From tag */
+	gen_call_id_ftag(&rec->td.rem_uri, now, &call_id_ftag);
+	memcpy(p, call_id_ftag.s, call_id_ftag.len);
+
+	/* reset the CSeq for the new Call-ID/ftag */
+	rec->td.loc_seq.value = 0;
+	//rec->td.loc_seq.is_set = 1;
+
+	return;
+}
+
+
+int add_record(uac_sub_map_t *uac, str *now, unsigned int plist)
+{
+	sub_record_t *record;
+	unsigned int size;
+	dlg_t *td;
+	str call_id_ftag;
+	char *p;
+	slinkedl_list_t *list;
+
+	/* Reserve space for record */
+	size = sizeof(sub_record_t) + MD5_LEN +
+		uac->to_uri.len + uac->from_uri.len + uac->subserver_uri.len +
+		uac->auth_user.len + uac->auth_password.len +
+		uac->contact_uri.len + uac->contact_params.len + uac->proxy_uri.len +
+		uac->extra_headers.len ;
+
+	if(plist==0) list = sub_htable[uac->hash_code].p_list;
+	else list = sub_htable[uac->hash_code].s_list;
+
+	record = (sub_record_t*)slinkedl_append(list, size);
+	if(!record) {
+		LM_ERR("oom\n");
+		return -1;
+	}
+	memset(record, 0, size);
+
+	record->expires = uac->expires;
+
+	td = &(record->td);
+	p = (char *)(record + 1);
+
+	/* Setting the td->id */
+	gen_call_id_ftag(&uac->to_uri, now, &call_id_ftag);
+	memcpy(p, call_id_ftag.s, call_id_ftag.len);
+	td->id.call_id.s = p;
+	td->id.call_id.len = MD5_LEN - 5;
+	td->id.loc_tag.s = p + MD5_LEN - 5;
+	td->id.loc_tag.len = 5;
+	p += MD5_LEN;
+
+	//td->id.rem_tag.s = NULL;
+	//td->id.rem_tag.len = 0;
+
+	/* Setting the CSeq */
+	td->loc_seq.value = 0;
+	td->loc_seq.is_set = 1;
+	//td->loc_seq.rem_tag.s = NULL;
+	//td->loc_seq.rem_tag.len = 0;
+
+	/* Setting the hooks */
+	//td->hooks <- hooks for SUBSCRIBE
+	td->hooks.request_uri = &uac->to_uri;
+
+	/* Setting the remote URI */
+	td->rem_uri.s = p;
+	td->rem_uri.len = uac->to_uri.len;
+
+	memcpy(p, uac->to_uri.s, uac->to_uri.len);
+	p += uac->to_uri.len;
+
+	/* Setting the outbound proxy */
+	if (uac->proxy_uri.s && uac->proxy_uri.len) {
+		td->obp.s = p;
+		td->obp.len = uac->proxy_uri.len;
+		memcpy(p, uac->proxy_uri.s, uac->proxy_uri.len);
+		p += uac->proxy_uri.len;
+	}
+
+	/* Setting the local URI */
+	if(uac->from_uri.s && uac->from_uri.len) {
+		LM_DBG("got from [%.*s]\n", uac->from_uri.len, uac->from_uri.s);
+		td->loc_uri.s = p;
+		td->loc_uri.len = uac->from_uri.len;
+		memcpy(p, uac->from_uri.s, uac->from_uri.len);
+		p += uac->from_uri.len;
+	} else {
+		td->loc_uri.s = td->rem_uri.s;
+		td->loc_uri.len = td->rem_uri.len;
+	}
+
+	/* Setting the Remote target URI */
+	td->rem_target.s = p;
+	td->rem_target.len = uac->subserver_uri.len;
+	memcpy(p, uac->subserver_uri.s, uac->subserver_uri.len);
+	p += uac->subserver_uri.len;
+
+	/* Setting the Local/Remote Display Name */
+	//td->loc_dname.s = td->rem_dname.s = NULL;
+	//td->loc_dname.len = td->rem_dname.len = 0;
+
+	//td->T_flags = 0;
+	td->state = DLG_CONFIRMED;
+
+	/* Setting the Route set */
+	//td->route_set = NULL;
+	/* Setting the socket */
+	td->send_sock = uac->send_sock;
+	/* Done with td */
+
+	if (uac->auth_user.s && uac->auth_user.len) {
+		record->auth_user.s = p;
+		record->auth_user.len = uac->auth_user.len;
+		memcpy(p, uac->auth_user.s, uac->auth_user.len);
+		p += uac->auth_user.len;
+	}
+
+	if (uac->auth_password.s && uac->auth_password.len) {
+		record->auth_password.s = p;
+		record->auth_password.len = uac->auth_password.len;
+		memcpy(p, uac->auth_password.s, uac->auth_password.len);
+		p += uac->auth_password.len;
+	}
+
+	if (uac->extra_headers.s && uac->extra_headers.len) {
+		record->extra_headers.s = p;
+		record->extra_headers.len = uac->extra_headers.len;
+		memcpy(p, uac->extra_headers.s, uac->extra_headers.len);
+		p += uac->extra_headers.len;
+	}
+
+	record->contact_uri.s = p;
+	record->contact_uri.len = uac->contact_uri.len;
+	memcpy(p, uac->contact_uri.s, uac->contact_uri.len);
+	p += uac->contact_uri.len;
+
+	if (uac->contact_params.s && uac->contact_params.len) {
+		record->contact_params.s = p;
+		record->contact_params.len = uac->contact_params.len;
+		memcpy(p, uac->contact_params.s, uac->contact_params.len);
+		p += uac->contact_params.len;
+	}
+
+	sub_print_record(record);
+
+	return 0;
+}
+
+void *sub_alloc(size_t size) { return shm_malloc(size); }
+void sub_free(void *ptr) { shm_free(ptr); return; }
+
+int init_sub_htable(void) {
+	int i;
+
+	sub_htable = (sub_table_t)shm_malloc(sub_hsize * sizeof(sub_entry_t));
+	if(!sub_htable) {
+		LM_ERR("oom\n");
+		return -1;
+	}
+
+	for(i= 0; i<sub_hsize; i++) {
+		lock_init(&sub_htable[i].lock);
+		sub_htable[i].p_list = slinkedl_init(&sub_alloc, &sub_free);
+		LM_DBG("sub_htable[%d].p_list=[%p]\n", i, sub_htable[i].p_list);
+		if (sub_htable[i].p_list == NULL) {
+			LM_ERR("oom while allocating list\n");
+			return -1;
+		}
+		sub_htable[i].s_list = NULL;
+	}
+	return 0;
+}
+
+
+void destroy_sub_htable(void) {
+	int i;
+
+	if (sub_htable) {
+		for(i=0; i<sub_hsize; i++) {
+			lock_destroy(&sub_htable[i].lock);
+			slinkedl_list_destroy(sub_htable[i].p_list);
+			sub_htable[i].p_list = NULL;
+		}
+		shm_free(sub_htable);
+		sub_htable = NULL;
+	}
+}
+
diff --git a/modules/uac_subclient/sub_records.h b/modules/uac_subclient/sub_records.h
new file mode 100644
index 0000000..9409d98
--- /dev/null
+++ b/modules/uac_subclient/sub_records.h
@@ -0,0 +1,105 @@
+/*
+ * subclient module
+ *
+ * Copyright (C) 2011 VoIP Embedded Inc.
+ *
+ * This file is part of opensips, a free SIP server.
+ *
+ * opensips is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ * opensips is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
+ *
+ * History:
+ * --------
+ *  2011-02-11  initial version (Ovidiu Sas)
+ */
+
+#ifndef SUB_RECORDS
+#define SUB_RECORDS
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "../../lock_ops.h"
+#include "../../ut.h"
+#include "../../mem/shm_mem.h"
+#include "../tm/dlg.h"
+#include "../tm/tm_load.h"
+#include "../../sliblist.h"
+
+
+#define NOT_SUBSCRIBED_STATE	0
+#define SUBSCRIBING_STATE	1
+#define AUTHENTICATING_STATE	2
+#define SUBSCRIBED_STATE	3
+#define SUBSCRIBE_TIMEOUT_STATE	4
+#define INTERNAL_ERROR_STATE	5
+#define WRONG_CREDENTIALS_STATE	6
+#define SUBSERVER_ERROR_STATE	7
+
+
+typedef struct uac_sub_map {
+	unsigned int hash_code;
+	str subserver_uri;		/* subserver */
+	str proxy_uri;			/* proxy */
+	str to_uri;			/* AOR */
+	str from_uri;			/* third party subclient */
+	str contact_uri;		/* contact binding */
+	str contact_params;		/* contact params */
+	str auth_user;			/* authentication user */
+	str auth_password;		/* authentication password */
+	str extra_headers;		/* extra headers Event,Accept etc. */
+	unsigned int expires;		/* expiration interval */
+	struct socket_info *send_sock;	/* socket */
+	struct uac_sub_map *next;
+} uac_sub_map_t;
+
+
+
+
+typedef struct sub_record {
+	dlg_t td;
+	str contact_uri;
+	str contact_params;
+	str auth_user;
+	str auth_password;
+	str extra_headers;		/* extra headers Event,Accept etc. */
+	unsigned int state;
+	unsigned int expires;
+	time_t last_subscribe_sent;
+	time_t subistration_timeout;
+	struct sub_record *prev;
+	struct sub_record *next;
+} sub_record_t;
+
+typedef struct sub_entry {
+	slinkedl_list_t *p_list;
+	slinkedl_list_t *s_list;
+	gen_lock_t lock;
+} sub_entry_t;
+
+typedef sub_entry_t *sub_table_t;
+
+extern sub_table_t sub_htable;
+extern unsigned int sub_hsize;
+
+void *sub_alloc(size_t size);
+void sub_free(void *ptr);
+int init_sub_htable(void);
+void destroy_sub_htable(void);
+
+void new_call_id_ftag_4_record(sub_record_t *rec, str *now);
+int add_record(uac_sub_map_t *uac, str *now, unsigned int plist);
+void sub_print_record(sub_record_t *rec);
+
+#endif
diff --git a/modules/uac_subclient/subclient.c b/modules/uac_subclient/subclient.c
new file mode 100644
index 0000000..79bd3a9
--- /dev/null
+++ b/modules/uac_subclient/subclient.c
@@ -0,0 +1,928 @@
+/*
+ * subclient module
+ *
+ * Copyright (C) 2011 VoIP Embedded Inc.
+ *
+ * This file is part of opensips, a free SIP server.
+ *
+ * opensips is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ * opensips is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
+ *
+ * History:
+ * --------
+ *  2011-02-11  initial version (Ovidiu Sas)
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include "../../sr_module.h"
+#include "../../timer.h"
+#include "../../db/db.h"
+#include "../../parser/parse_uri.h"
+#include "../../parser/parse_authenticate.h"
+#include "../../parser/contact/parse_contact.h"
+#include "../../parser/parse_min_expires.h"
+#include "../uac_auth/uac_auth.h"
+#include "sub_records.h"
+#include "sub_db_handler.h"
+
+
+#define UAC_SUBSERVER_URI_PARAM              1
+#define UAC_PROXY_URI_PARAM                  2
+#define UAC_AOR_URI_PARAM                    3
+#define UAC_THIRD_PARTY_SUBCLIENT_URI_PARAM 4
+#define UAC_AUTH_USER_PARAM                  5
+#define UAC_AUTH_PASSWORD_PARAM              6
+#define UAC_CONTACT_URI_PARAM                7
+#define UAC_CONTACT_PARAMS_PARAM             8
+#define UAC_EXPIRES_PARAM                    9
+#define UAC_FORCED_SOCKET_PARAM             10
+#define UAC_MAX_PARAMS_NO                   11
+
+#define UAC_SUB_NOT_SUBSCRIBED_STATE    "NOT_SUBSCRIBED_STATE"
+#define UAC_SUB_SUBSCRIBING_STATE       "SUBSCRIBING_STATE"
+#define UAC_SUB_AUTHENTICATING_STATE    "AUTHENTICATING_STATE"
+#define UAC_SUB_SUBSCRIBED_STATE        "SUBSCRIBED_STATE"
+#define UAC_SUB_SUBSCRIBE_TIMEOUT_STATE  "SUBSCRIBE_TIMEOUT_STATE"
+#define UAC_SUB_INTERNAL_ERROR_STATE    "INTERNAL_ERROR_STATE"
+#define UAC_SUB_WRONG_CREDENTIALS_STATE "WRONG_CREDENTIALS_STATE"
+#define UAC_SUB_SUBSERVER_ERROR_STATE   "SUBSERVER_ERROR_STATE"
+
+const str uac_sub_state[]={
+	str_init(UAC_SUB_NOT_SUBSCRIBED_STATE),
+	str_init(UAC_SUB_SUBSCRIBING_STATE),
+	str_init(UAC_SUB_AUTHENTICATING_STATE),
+	str_init(UAC_SUB_SUBSCRIBED_STATE),
+	str_init(UAC_SUB_SUBSCRIBE_TIMEOUT_STATE),
+	str_init(UAC_SUB_INTERNAL_ERROR_STATE),
+	str_init(UAC_SUB_WRONG_CREDENTIALS_STATE),
+	str_init(UAC_SUB_SUBSERVER_ERROR_STATE),
+};
+
+/** Functions declarations */
+static int mod_init(void);
+static void mod_destroy(void);
+static int child_init(int rank);
+
+void timer_check(unsigned int ticks, void* hash_counter);
+
+static struct mi_root* mi_sub_list(struct mi_root* cmd, void* param);
+static struct mi_root* mi_sub_reload(struct mi_root* cmd, void* param);
+int send_subscribe(unsigned int hash_index, sub_record_t *rec, str *auth_hdr);
+
+
+/** Global variables */
+
+uac_auth_api_t uac_auth_api;
+
+unsigned int default_expires = 3600;
+unsigned int timer_interval = 100;
+
+sub_table_t sub_htable = NULL;
+unsigned int sub_hsize = 1;
+
+static str db_url = {NULL, 0};
+
+static str subscribe_method = str_init("SUBSCRIBE");
+static str contact_hdr = str_init("Contact: ");
+static str expires_hdr = str_init("Expires: ");
+static str expires_param = str_init(";expires=");
+
+char extra_hdrs_buf[512];
+static str extra_hdrs={extra_hdrs_buf, 512};
+
+
+/* TM bind */
+struct tm_binds tmb;
+
+
+typedef struct sub_tm_cb {
+	unsigned int hash_index;
+	sub_record_t *uac;
+}sub_tm_cb_t;
+
+/** Exported functions */
+static cmd_export_t cmds[]=
+{
+	{0,0,0,0,0,0}
+};
+
+
+/** Exported parameters */
+static param_export_t params[]= {
+	{"hash_size",		INT_PARAM,			&sub_hsize},
+	{"default_expires",	INT_PARAM,			&default_expires},
+	{"timer_interval",	INT_PARAM,			&timer_interval},
+	{"db_url",		STR_PARAM,			&db_url.s},
+	{"table_name",		STR_PARAM,			&sub_table_name},
+	{"subserver_column",	STR_PARAM,			&subserver_column.s},
+	{"proxy_column",	STR_PARAM,			&proxy_column.s},
+	{"aor_column",		STR_PARAM,			&aor_column.s},
+	{"third_party_subclient_column",STR_PARAM,&third_party_subclient_column.s},
+	{"username_column",	STR_PARAM,		&username_column.s},
+	{"password_column",	STR_PARAM,		&password_column.s},
+	{"binding_URI_column",	STR_PARAM,		&binding_URI_column.s},
+	{"binding_params_column",	STR_PARAM,	&binding_params_column.s},
+	{"expiry_column",	STR_PARAM,		&expiry_column.s},
+	{"forced_socket_column",	STR_PARAM,	&forced_socket_column.s},
+	{0,0,0}
+};
+
+
+/** MI commands */
+static mi_export_t mi_cmds[] = {
+	{"sub_list",   0, mi_sub_list,   0, 0, 0},
+	{"sub_reload", 0, mi_sub_reload, 0,	0, 0},
+	{0,            0, 0,             0, 0, 0}
+};
+
+static dep_export_t deps = {
+	{ /* OpenSIPS module dependencies */
+		{ MOD_TYPE_DEFAULT, "tm",       DEP_ABORT },
+		{ MOD_TYPE_DEFAULT, "uac_auth", DEP_ABORT },
+		{ MOD_TYPE_NULL, NULL, 0 },
+	},
+	{ /* modparam dependencies */
+		{ NULL, NULL },
+	},
+};
+
+/** Module interface */
+struct module_exports exports= {
+	"uac_subclient",		/* module name */
+	MOD_TYPE_DEFAULT,       /* class of this module */
+	MODULE_VERSION,			/* module version */
+	DEFAULT_DLFLAGS,		/* dlopen flags */
+	&deps,                  /* OpenSIPS module dependencies */
+	cmds,				/* exported functions */
+	0,					/* exported async functions */
+	params,				/* exported parameters */
+	NULL,				/* exported statistics */
+	mi_cmds,			/* exported MI functions */
+	NULL,				/* exported pseudo-variables */
+	0,				/* extra processes */
+	mod_init,			/* module initialization function */
+	(response_function) NULL,	/* response handling function */
+	(destroy_function) mod_destroy,	/* destroy function */
+	child_init			/* per-child init function */
+};
+
+
+/** Module init function */
+static int mod_init(void)
+{
+	unsigned int _timer;
+	int *param;
+
+	if(load_uac_auth_api(&uac_auth_api)<0){
+		LM_ERR("Failed to load uac_auth api\n");
+		return -1;
+	}
+
+	/* load all TM stuff */
+	if(load_tm_api(&tmb)==-1) {
+		LM_ERR("can't load tm functions\n");
+		return -1;
+	}
+
+	if(default_expires<15){
+		LM_ERR("default_expires to short: [%d]<15\n", default_expires);
+		return -1;
+	}
+	if(timer_interval<10){
+		LM_ERR("timer_interval to short: [%d]<10\n", timer_interval);
+		return -1;
+	}
+	if(sub_hsize<1 || sub_hsize>20) {
+		LM_ERR("Wrong hash size: 20<[%d]<1\n", sub_hsize);
+	}
+	sub_hsize = 1<<sub_hsize;
+
+	if(init_sub_htable()<0) {
+		LM_ERR("Failed to initialize subclient hash table\n");
+		return -1;
+	}
+
+	sub_table_name.len = strlen(sub_table_name.s);
+	subserver_column.len = strlen(subserver_column.s);
+	proxy_column.len = strlen(proxy_column.s);
+	aor_column.len = strlen(aor_column.s);
+	third_party_subclient_column.len =
+		strlen(third_party_subclient_column.s);
+	username_column.len = strlen(username_column.s);
+	password_column.len = strlen(password_column.s);
+	binding_URI_column.len = strlen(binding_URI_column.s);
+	binding_params_column.len = strlen(binding_params_column.s);
+	expiry_column.len = strlen(expiry_column.s);
+	forced_socket_column.len = strlen(forced_socket_column.s);
+	init_db_url(db_url , 0 /*cannot be null*/);
+	if (init_sub_db(&db_url) != 0) {
+		LM_ERR("failed to initialize the DB support\n");
+		return -1;
+	}
+
+	/* allocate a shm variable to keep the counter used by the timer
+	 * routine - it must be shared as the routine get executed
+	 * in different processes */
+	if (NULL==(param=(int*) shm_malloc(sizeof(int)))) {
+		LM_ERR("cannot allocate shm memory for keepalive counter\n");
+		return -1;
+	}
+	*param = 0;
+
+	_timer = timer_interval/sub_hsize;
+	if (_timer) {
+		register_timer("uac_sub_check", timer_check, (void*)(long)param, _timer,
+			TIMER_FLAG_DELAY_ON_DELAY);
+	} else {
+		LM_ERR("timer_interval=[%d] MUST be bigger then sub_hsize=[%d]\n",
+			timer_interval, sub_hsize);
+		return -1;
+	}
+
+	return 0;
+}
+
+
+static void mod_destroy(void)
+{
+	destroy_sub_htable();
+
+	LM_DBG("done\n");
+	return;
+}
+
+static int child_init(int rank)
+{
+	if (db_url.s != NULL && connect_sub_db(&db_url)) {
+		LM_ERR("failed to connect to db (rank=%d)\n",rank);
+		return -1;
+	}
+	return 0;
+}
+
+
+void shm_free_param(void* param) {shm_free(param);}
+
+struct sub_tm_cback_data {
+	struct cell *t;
+	struct tmcb_params *ps;
+	time_t now;
+	sub_tm_cb_t *cb_param;
+};
+
+int run_sub_tm_cback(void *e_data, void *data, void *r_data)
+{
+	struct sip_msg *msg;
+	int statuscode = 0;
+	unsigned int exp = 0;
+	sub_record_t *rec = (sub_record_t*)e_data;
+	struct hdr_field *c_ptr, *head_contact;
+	struct uac_credential crd;
+	contact_t *contact;
+	struct authenticate_body *auth = NULL;
+	static struct authenticate_nc_cnonce auth_nc_cnonce;
+	HASHHEX response;
+	str *new_hdr;
+	struct sub_tm_cback_data *tm_cback_data = (struct sub_tm_cback_data*)data;
+	struct cell *t;
+	struct tmcb_params *ps;
+	time_t now;
+	sub_tm_cb_t *cb_param;
+
+	cb_param = tm_cback_data->cb_param;
+	if (rec!=cb_param->uac) {
+		/* no action on current list elemnt */
+		return 0; /* continue list traversal */
+	}
+
+	t = tm_cback_data->t;
+	ps = tm_cback_data->ps;
+	now = tm_cback_data->now;
+
+	sub_print_record(rec);
+
+	if (ps->rpl==FAKED_REPLY)
+		memset(&rec->td.forced_to_su, 0, sizeof(union sockaddr_union));
+	else if (rec->td.forced_to_su.s.sa_family == AF_UNSPEC)
+		rec->td.forced_to_su = t->uac[0].request.dst.to;
+
+	statuscode = ps->code;
+	switch(statuscode) {
+	case 200:
+		msg = ps->rpl;
+		if(msg==FAKED_REPLY) {
+			LM_ERR("FAKED_REPLY\n");
+			goto done;
+		}
+		if (parse_headers(msg, HDR_EOH_F, 0) == -1) {
+			LM_ERR("failed to parse headers\n");
+			goto done;
+		}
+		if (msg->contact) {
+			c_ptr = msg->contact;
+			while(c_ptr) {
+				if (c_ptr->type == HDR_CONTACT_T) {
+					if (!c_ptr->parsed && (parse_contact(c_ptr)<0)) {
+						LM_ERR("failed to parse Contact body\n");
+						goto done;
+					}
+				}
+				c_ptr = c_ptr->next;
+			}
+		} else {
+			LM_ERR("No contact header in received 200ok\n");
+			goto done;
+		}
+		head_contact = msg->contact;
+		contact = ((contact_body_t*)msg->contact->parsed)->contacts;
+		while (contact) {
+			/* Check for binding */
+			if (contact->uri.len==rec->contact_uri.len &&
+				strncmp(contact->uri.s,rec->contact_uri.s,contact->uri.len)==0){
+				if (contact->expires && contact->expires->body.len) {
+					if (str2int(&contact->expires->body, &exp)<0) {
+						LM_ERR("Unable to extract expires from [%.*s]"
+							" for binding [%.*s]\n",
+							contact->expires->body.len,
+							contact->expires->body.s,
+							contact->uri.len, contact->uri.s);
+					}
+				}
+				break;
+			}
+
+			/* get the next contact */
+			if (contact->next == NULL) {
+				contact = NULL;
+				c_ptr = head_contact->next;
+				while(c_ptr) {
+					if (c_ptr->type == HDR_CONTACT_T) {
+						head_contact = c_ptr;
+						contact = ((contact_body_t*)c_ptr->parsed)->contacts;
+						break;
+					}
+					c_ptr = c_ptr->next;
+				}
+			} else {
+				contact = contact->next;
+			}
+		}
+		rec->state = SUBSCRIBED_STATE;
+		if (exp) rec->expires = exp;
+		if (rec->expires <= timer_interval) {
+			LM_ERR("Please decrease timer_interval=[%u]"
+				" - imposed server expires [%u] to small for AOR=[%.*s]\n",
+				timer_interval, rec->expires,
+				rec->td.rem_uri.len, rec->td.rem_uri.s);
+		}
+		rec->subistration_timeout = now + rec->expires - timer_interval;
+		break;
+
+	case WWW_AUTH_CODE:
+	case PROXY_AUTH_CODE:
+		msg = ps->rpl;
+		if(msg==FAKED_REPLY) {
+			LM_ERR("FAKED_REPLY\n");
+			goto done;
+		}
+
+		if (rec->auth_user.s==NULL || rec->auth_user.len==0 ||
+			rec->auth_password.s==NULL || rec->auth_password.len==0) {
+			LM_ERR("Credentials not provisioned\n");
+			rec->state = WRONG_CREDENTIALS_STATE;
+			rec->subistration_timeout = 0;
+			/* action successfully completed on current list element */
+			return 1; /* exit list traversal */
+		}
+
+		if (statuscode==WWW_AUTH_CODE) {
+			if (0 == parse_www_authenticate_header(msg))
+				auth = get_www_authenticate(msg);
+		} else if (statuscode==PROXY_AUTH_CODE) {
+			if (0 == parse_proxy_authenticate_header(msg))
+				auth = get_proxy_authenticate(msg);
+		}
+		if (auth == NULL) {
+			LM_ERR("Unable to extract authentication info\n");
+			goto done;
+		}
+		LM_DBG("flags=[%d] realm=[%.*s] domain=[%.*s] nonce=[%.*s]"
+			" opaque=[%.*s] qop=[%.*s]\n",
+			auth->flags,
+			auth->realm.len, auth->realm.s,
+			auth->domain.len, auth->domain.s,
+			auth->nonce.len, auth->nonce.s,
+			auth->opaque.len, auth->opaque.s,
+			auth->qop.len, auth->qop.s);
+
+		switch(rec->state) {
+		case SUBSCRIBING_STATE:
+			break;
+		case AUTHENTICATING_STATE:
+			/* We already sent an authenticated SUBSCRIBE and we are still challanged! */
+			LM_WARN("Wrong credentials for [%.*s]\n",
+				rec->td.rem_uri.len, rec->td.rem_uri.s);
+			rec->state = WRONG_CREDENTIALS_STATE;
+			rec->subistration_timeout = 0;
+			/* action successfully completed on current list element */
+			return 1; /* exit list traversal */
+		default:
+			LM_ERR("Unexpected [%d] notification cb in state [%d]\n",
+				statuscode, rec->state);
+			goto done;
+		}
+
+		/* perform authentication */
+		if (auth->realm.s && auth->realm.len) {
+			crd.realm.s = auth->realm.s; crd.realm.len = auth->realm.len;
+		} else {
+			LM_ERR("No realm found\n");
+			goto done;
+		}
+		crd.user.s = rec->auth_user.s; crd.user.len = rec->auth_user.len;
+		crd.passwd.s = rec->auth_password.s; crd.passwd.len = rec->auth_password.len;
+
+		memset(&auth_nc_cnonce, 0, sizeof(struct authenticate_nc_cnonce));
+		uac_auth_api._do_uac_auth(&subscribe_method, &rec->td.rem_target, &crd,
+					auth, &auth_nc_cnonce, response);
+		new_hdr = uac_auth_api._build_authorization_hdr(statuscode, &rec->td.rem_target,
+					&crd, auth, &auth_nc_cnonce, response);
+		if (!new_hdr) {
+			LM_ERR("failed to build authorization hdr\n");
+			goto done;
+		}
+		if(send_subscribe(cb_param->hash_index, rec, new_hdr)==1) {
+			rec->state = AUTHENTICATING_STATE;
+		} else {
+			rec->state = INTERNAL_ERROR_STATE;
+		}
+		pkg_free(new_hdr->s);
+		new_hdr->s = NULL; new_hdr->len = 0;
+		break;
+
+	case 423: /* Interval Too Brief */
+		msg = ps->rpl;
+		if(msg==FAKED_REPLY) {
+			LM_ERR("FAKED_REPLY\n");
+			goto done;
+		}
+		if (0 == parse_min_expires(msg)) {
+			rec->expires = (unsigned int)(long)msg->min_expires->parsed;
+			if(send_subscribe(cb_param->hash_index, rec, NULL)==1)
+				rec->state = SUBSCRIBING_STATE;
+			else
+				rec->state = INTERNAL_ERROR_STATE;
+		} else {
+			rec->state = SUBSERVER_ERROR_STATE;
+			rec->subistration_timeout = now + rec->expires - timer_interval;
+		}
+		break;
+
+	case 408: /* Interval Too Brief */
+		rec->state = SUBSCRIBE_TIMEOUT_STATE;
+		rec->subistration_timeout = now + rec->expires - timer_interval;
+		break;
+
+	default:
+		if(statuscode<400 && statuscode>=300) {
+			LM_ERR("Redirection not implemented yet\n");
+			rec->state = INTERNAL_ERROR_STATE;
+		} else {
+			/* we got an error from the server */
+			rec->state = SUBSERVER_ERROR_STATE;
+			rec->subistration_timeout = now + rec->expires - timer_interval;
+
+		}
+	}
+
+	/* action successfully completed on current list element */
+	return 1; /* exit list traversal */
+done:
+	rec->state = INTERNAL_ERROR_STATE;
+	rec->subistration_timeout = now + rec->expires;
+	return -1; /* exit list traversal */
+}
+
+
+
+void sub_tm_cback(struct cell *t, int type, struct tmcb_params *ps)
+{
+	sub_tm_cb_t *cb_param;
+	int statuscode = 0;
+	int ret;
+	time_t now;
+	struct sub_tm_cback_data tm_cback_data;
+
+	if(ps==NULL || ps->rpl==NULL) {
+		LM_ERR("wrong ps parameter\n");
+		return;
+	}
+	if(ps->param==NULL || *ps->param==NULL) {
+		LM_ERR("null callback parameter\n");
+		return;
+	}
+	cb_param = (sub_tm_cb_t *)*ps->param;
+	if(cb_param->uac == NULL) {
+		LM_ERR("null record\n");
+		return;
+	}
+	statuscode = ps->code;
+	now = time(0);
+	LM_DBG("tm [%p] notification cb for %s [%d] reply at [%d]\n",
+			t, (ps->rpl==FAKED_REPLY)?"FAKED_REPLY":"",
+			statuscode, (unsigned int)now);
+
+	if(cb_param->uac) {
+		LM_DBG("%s:%d: contact:%.*s:\n", __func__, __LINE__,cb_param->uac->contact_uri.len, cb_param->uac->contact_uri.s);
+	}
+
+	if(statuscode<200) return;
+
+	/* Initialize slinkedl run traversal data */
+	tm_cback_data.t = t;
+    tm_cback_data.ps = ps;
+    tm_cback_data.cb_param = cb_param;
+	tm_cback_data.now = now;
+
+	lock_get(&sub_htable[cb_param->hash_index].lock);
+	ret = slinkedl_traverse(sub_htable[cb_param->hash_index].p_list,
+						&run_sub_tm_cback, (void*)&tm_cback_data, NULL);
+	lock_release(&sub_htable[cb_param->hash_index].lock);
+
+	if (ret==0) {
+		LM_ERR("record [%p] not found on hash index [%d]\n",
+		cb_param->uac, cb_param->hash_index);
+	}
+
+	return;
+}
+
+
+int send_subscribe(unsigned int hash_index, sub_record_t *rec, str *auth_hdr)
+{
+	int result, expires_len;
+	sub_tm_cb_t *cb_param;
+	char *p, *expires;
+
+	/* Allocate space for tm callback params */
+	cb_param = shm_malloc(sizeof(sub_tm_cb_t));
+	if (!cb_param) {
+		LM_ERR("oom\n");
+		return -1;
+	}
+	cb_param->hash_index = hash_index;
+	cb_param->uac = rec;
+
+	/* get the string version of expires */
+	expires = int2str((unsigned long)(rec->expires), &expires_len);
+
+	p = extra_hdrs.s;
+	memcpy(p, contact_hdr.s, contact_hdr.len);
+	p += contact_hdr.len;
+	*p = '<'; p++;
+	memcpy(p, rec->contact_uri.s, rec->contact_uri.len);
+	p += rec->contact_uri.len;
+	*p = '>'; p++;
+	memcpy(p, rec->contact_params.s, rec->contact_params.len);
+	p += rec->contact_params.len;
+	if (1) {
+		/* adding exiration time as a parameter */
+		memcpy(p, expires_param.s, expires_param.len);
+		p += expires_param.len;
+	} else {
+		/* adding exiration time as a header */
+		memcpy(p, CRLF, CRLF_LEN); p += CRLF_LEN;
+		memcpy(p, expires_hdr.s, expires_hdr.len);
+		p += expires_hdr.len;
+	}
+	memcpy(p, expires, expires_len);
+	p += expires_len;
+	memcpy(p, CRLF, CRLF_LEN); p += CRLF_LEN;
+
+	if(rec->extra_headers.len>0) { /* CRLF should be inside */
+		memcpy(p, rec->extra_headers.s, rec->extra_headers.len);
+		p += rec->extra_headers.len;
+		memcpy(p, CRLF, CRLF_LEN); p += CRLF_LEN;
+	}
+
+	if (auth_hdr) {
+		memcpy(p, auth_hdr->s, auth_hdr->len);
+		p += auth_hdr->len;
+	}
+	extra_hdrs.len = (int)(p - extra_hdrs.s);
+
+	LM_DBG("extra_hdrs=[%p][%d]->[%.*s]\n",
+		extra_hdrs.s, extra_hdrs.len, extra_hdrs.len, extra_hdrs.s);
+
+	result=tmb.t_request_within(
+		&subscribe_method,	/* method */
+		&extra_hdrs,		/* extra headers*/
+		NULL,			/* body */
+		&rec->td,		/* dialog structure*/
+		sub_tm_cback,		/* callback function */
+		(void *)cb_param,	/* callback param */
+		shm_free_param);	/* function to release the parameter */
+	LM_DBG("result=[%d]\n", result);
+	return result;
+}
+
+
+struct timer_check_data {
+	time_t now;
+	str *s_now;
+	int hash_counter;
+};
+
+int run_timer_check(void *e_data, void *data, void *r_data)
+{
+	sub_record_t *rec = (sub_record_t*)e_data;
+	struct timer_check_data *t_check_data = (struct timer_check_data*)data;
+	time_t now = t_check_data->now;
+	str *s_now = t_check_data->s_now;
+	unsigned int i = t_check_data->hash_counter;
+
+	switch(rec->state){
+	case SUBSCRIBING_STATE:
+	case AUTHENTICATING_STATE:
+		break;
+	case WRONG_CREDENTIALS_STATE:
+	case SUBSCRIBE_TIMEOUT_STATE:
+	case INTERNAL_ERROR_STATE:
+	case SUBSERVER_ERROR_STATE:
+		sub_print_record(rec);
+		new_call_id_ftag_4_record(rec, s_now);
+		if(send_subscribe(i, rec, NULL)==1) {
+			rec->last_subscribe_sent = now;
+			rec->state = SUBSCRIBING_STATE;
+		} else {
+			rec->subistration_timeout = now + rec->expires - timer_interval;
+			rec->state = INTERNAL_ERROR_STATE;
+		}
+		break;
+	case SUBSCRIBED_STATE:
+		/* check if we need to re-subscribe */
+		if (now < rec->subistration_timeout) {
+			break;
+		}
+	case NOT_SUBSCRIBED_STATE:
+		if(send_subscribe(i, rec, NULL)==1) {
+			rec->last_subscribe_sent = now;
+			rec->state = SUBSCRIBING_STATE;
+		} else {
+			rec->subistration_timeout = now + rec->expires - timer_interval;
+			rec->state = INTERNAL_ERROR_STATE;
+		}
+		break;
+	default:
+		LM_ERR("Unexpected state [%d] for rec [%p]\n", rec->state, rec);
+	}
+
+	return 0; /* continue list traversal */
+}
+
+
+void timer_check(unsigned int ticks, void* hash_counter)
+{
+	unsigned int i=*(unsigned*)(unsigned long*)hash_counter;
+	char *p;
+	int len, ret;
+	time_t now;
+	str str_now = {NULL, 0};
+	struct timer_check_data t_check_data;
+
+	now = time(0);
+	*(unsigned*)(unsigned long*)hash_counter = (i+1)%sub_hsize;
+
+	p = int2str((unsigned long)(time(0)), &len);
+	if (p && len>0) {
+		str_now.s = (char *)pkg_malloc(len);
+		if (str_now.s) {
+			memcpy(str_now.s, p, len);
+			str_now.len = len;
+		} else {
+			LM_ERR("oom\n");
+			return;
+		}
+	}
+
+	/* Initialize slinkedl run traversal data */
+	t_check_data.now = now;
+	t_check_data.s_now = &str_now;
+	t_check_data.hash_counter = i;
+
+	LM_DBG("checking ... [%d] on htable[%d]\n", (unsigned int)now, i);
+	lock_get(&sub_htable[i].lock);
+	ret = slinkedl_traverse(sub_htable[i].p_list, &run_timer_check,
+							(void*)&t_check_data, NULL);
+	if (ret<0) LM_CRIT("Unexpected return code %d\n", ret);
+	lock_release(&sub_htable[i].lock);
+
+	if (str_now.s) {pkg_free(str_now.s);}
+
+	return;
+}
+
+
+/*** MI **/
+
+int run_mi_sub_list(void *e_data, void *data, void *r_data)
+{
+	struct mi_root* rpl_tree = (struct mi_root*)data;
+	struct mi_node *node, *node1;
+	struct mi_attr* attr;
+	sub_record_t *rec = (sub_record_t*)e_data;
+	int len;
+	char* p;
+	struct ip_addr addr;
+
+	node = add_mi_node_child(&rpl_tree->node, MI_DUP_VALUE, "AOR", 3,
+							rec->td.rem_uri.s, rec->td.rem_uri.len);
+	if(node == NULL) goto error;
+	p = int2str(rec->expires, &len);
+	attr = add_mi_attr(node, MI_DUP_VALUE, "expires", 7, p, len);
+	if(attr == NULL) goto error;
+
+	node1 = add_mi_node_child(node, MI_DUP_VALUE, "state", 5,
+							uac_sub_state[rec->state].s, uac_sub_state[rec->state].len);
+	if(node1 == NULL) goto error;
+
+	p = ctime(&rec->last_subscribe_sent);
+	len = strlen(p)-1;
+	node1 = add_mi_node_child(node, MI_DUP_VALUE, "last_subscribe_sent", 18, p, len);
+	if(node1 == NULL) goto error;
+
+	p = ctime(&rec->subistration_timeout);
+	len = strlen(p)-1;
+	node1 = add_mi_node_child(node, MI_DUP_VALUE, "subistration_t_out", 18, p, len);
+	if(node1 == NULL) goto error;
+
+	node1 = add_mi_node_child(node, MI_DUP_VALUE, "subserver", 9,
+							rec->td.rem_target.s, rec->td.rem_target.len);
+	if(node1 == NULL) goto error;
+
+	node1 = add_mi_node_child(node, MI_DUP_VALUE, "binding", 7,
+							rec->contact_uri.s, rec->contact_uri.len);
+	if(node1 == NULL) goto error;
+
+	if(rec->td.loc_uri.s != rec->td.rem_uri.s) {
+		node1 = add_mi_node_child(node, MI_DUP_VALUE,
+								"third_party_subclient", 12,
+								rec->td.loc_uri.s, rec->td.loc_uri.len);
+		if(node1 == NULL) goto error;
+	}
+
+	if (rec->td.obp.s && rec->td.obp.len) {
+		node1 = add_mi_node_child(node, MI_DUP_VALUE,
+								"proxy", 5, rec->td.obp.s, rec->td.obp.len);
+		if(node1 == NULL) goto error;
+	}
+
+	switch(rec->td.forced_to_su.s.sa_family) {
+	case AF_UNSPEC:
+		break;
+	case AF_INET:
+	case AF_INET6:
+		node1 = add_mi_node_child(node, MI_DUP_VALUE, "dst_IP", 6,
+			(rec->td.forced_to_su.s.sa_family==AF_INET)?"IPv4":"IPv6", 4);
+		sockaddr2ip_addr(&addr, &rec->td.forced_to_su.s);
+		p = ip_addr2a(&addr);
+		if (p == NULL) goto error;
+		len = strlen(p);
+		attr = add_mi_attr(node1, MI_DUP_VALUE, "ip", 2, p, len);
+		if(attr == NULL) goto error;
+		break;
+	default:
+		LM_ERR("unexpected sa_family [%d]\n", rec->td.forced_to_su.s.sa_family);
+		node1 = add_mi_node_child(node, MI_DUP_VALUE, "dst_IP", 6, "Error", 5);
+		p = int2str(rec->td.forced_to_su.s.sa_family, &len);
+		attr = add_mi_attr(node, MI_DUP_VALUE, "sa_family", 9, p, len);
+		if(attr == NULL) goto error;
+	}
+
+	/* action successfully completed on current list element */
+	return 0; /* continue list traversal */
+error:
+	LM_ERR("Unable to create reply\n");
+	return -1; /* exit list traversal */
+}
+
+
+static struct mi_root* mi_sub_list(struct mi_root* cmd, void* param)
+{
+	struct mi_root *rpl_tree;
+	int i, ret;
+
+	rpl_tree = init_mi_tree( 200, MI_OK_S, MI_OK_LEN);
+	if (rpl_tree==NULL) return NULL;
+	rpl_tree->node.flags |= MI_IS_ARRAY;
+
+	for(i=0; i<sub_hsize; i++) {
+		lock_get(&sub_htable[i].lock);
+		ret = slinkedl_traverse(sub_htable[i].p_list,
+						&run_mi_sub_list, (void*)rpl_tree, NULL);
+		lock_release(&sub_htable[i].lock);
+		if (ret<0) {
+			LM_ERR("Unable to create reply\n");
+			free_mi_tree(rpl_tree);
+			return NULL;
+		}
+	}
+	return rpl_tree;
+}
+
+int run_compare_rec(void *e_data, void *data, void *r_data)
+{
+	sub_record_t *old_rec = (sub_record_t*)e_data;
+	sub_record_t *new_rec = (sub_record_t*)data;
+
+	if ((old_rec->state == SUBSCRIBED_STATE) &&
+	    (str_strcmp(&old_rec->td.rem_uri, &new_rec->td.rem_uri) == 0)) {
+		memcpy(new_rec->td.id.call_id.s, old_rec->td.id.call_id.s,
+		    new_rec->td.id.call_id.len);
+		memcpy(new_rec->td.id.loc_tag.s, old_rec->td.id.loc_tag.s,
+		    new_rec->td.id.loc_tag.len);
+		new_rec->td.loc_seq.value = old_rec->td.loc_seq.value;
+		new_rec->last_subscribe_sent = old_rec->last_subscribe_sent;
+		new_rec->subistration_timeout = old_rec->subistration_timeout;
+		new_rec->state = old_rec->state;
+	}
+	return 0;
+}
+
+int run_find_same_rec(void *e_data, void *data, void *r_data)
+{
+	sub_record_t *new_rec = (sub_record_t*)e_data;
+	int i = *(int*)data;
+
+	slinkedl_traverse(sub_htable[i].p_list, &run_compare_rec, new_rec, NULL);
+	return 0;
+}
+
+static struct mi_root* mi_sub_reload(struct mi_root* cmd, void* param)
+{
+	struct mi_root *rpl_tree;
+	int i;
+	int err = 0;
+
+	rpl_tree = init_mi_tree( 200, MI_OK_S, MI_OK_LEN);
+	if (rpl_tree==NULL) return NULL;
+
+	for(i=0; i<sub_hsize; i++) {
+		lock_get(&sub_htable[i].lock);
+		if (sub_htable[i].s_list!=NULL) {
+			LM_ERR("Found non NULL s_list\n");
+			slinkedl_list_destroy(sub_htable[i].s_list);
+			sub_htable[i].s_list = NULL;
+		}
+		sub_htable[i].s_list = slinkedl_init(&sub_alloc, &sub_free);
+		if (sub_htable[i].p_list == NULL) {
+			LM_ERR("oom while allocating list\n");
+			err = 1;
+		}
+		lock_release(&sub_htable[i].lock);
+		if (err) goto error;
+	}
+	/* Load subclients into the secondary list */
+	if(load_sub_info_from_db(1) !=0){
+		LM_ERR("unable to reload the subclient data\n");
+		free_mi_tree(rpl_tree);
+		goto error;
+	}
+	/* Swap the lists: secondary will become primary */
+	for(i=0; i<sub_hsize; i++) {
+		lock_get(&sub_htable[i].lock);
+
+		slinkedl_traverse(sub_htable[i].s_list, &run_find_same_rec, &i, NULL);
+
+		slinkedl_list_destroy(sub_htable[i].p_list);
+		sub_htable[i].p_list = sub_htable[i].s_list;
+		sub_htable[i].s_list = NULL;
+		lock_release(&sub_htable[i].lock);
+	}
+
+	return rpl_tree;
+
+error:
+	for(i=0; i<sub_hsize; i++) {
+		lock_get(&sub_htable[i].lock);
+		if (sub_htable[i].s_list) slinkedl_list_destroy(sub_htable[i].s_list);
+		sub_htable[i].s_list = NULL;
+		lock_release(&sub_htable[i].lock);
+	}
+	return NULL;
+}
+
diff --git a/parser/parse_content.h b/parser/parse_content.h
index c636d60..3a5b25d 100644
--- a/parser/parse_content.h
+++ b/parser/parse_content.h
@@ -65,6 +65,8 @@ struct mime_type {
 #define SUBTYPE_ALL          0xfe
 #define SUBTYPE_UNKNOWN      0xff
 
+/*! \brief taken from PA module - will be useful here */
+#define MIMETYPE(x_,y_) ((TYPE_##x_ << 16) | (SUBTYPE_##y_))
 
 /*
  * Maximum number of mimes allowed in Accept header
diff --git a/parser/sdp/sdp_helpr_funcs.c b/parser/sdp/sdp_helpr_funcs.c
index 796c476..ea1aeb8 100644
--- a/parser/sdp/sdp_helpr_funcs.c
+++ b/parser/sdp/sdp_helpr_funcs.c
@@ -148,6 +148,21 @@ int get_mixed_part_delimiter(str* body, str *mp_delimiter)
 		advance(p,1,str_type,error);
 	mp_delimiter->len = str_type.len - (int)(p-str_type.s);
 	mp_delimiter->s = p;
+
+	if(mp_delimiter->s[0] == '"') {
+		if(mp_delimiter->s[mp_delimiter->len-1] == '"') {
+			mp_delimiter->len -= 2;
+			mp_delimiter->s++ ;
+		}
+	} else if(mp_delimiter->s[0] == '\'') {
+		if(mp_delimiter->s[mp_delimiter->len-1] == '\'') {
+			mp_delimiter->len -= 2;
+			mp_delimiter->s++ ;
+		}
+	} else {
+		LM_ERR("parse error: \" or \' found after boundary field\n");
+		goto error ;
+	}
 	return 1;
 
 error:
diff --git a/scripts/mysql/load_balancer-create.sql b/scripts/mysql/load_balancer-create.sql
index 8564783..37f3593 100644
--- a/scripts/mysql/load_balancer-create.sql
+++ b/scripts/mysql/load_balancer-create.sql
@@ -5,6 +5,7 @@ CREATE TABLE load_balancer (
     dst_uri CHAR(128) NOT NULL,
     resources CHAR(255) NOT NULL,
     probe_mode INT(11) UNSIGNED DEFAULT 0 NOT NULL,
+    socket CHAR(128) DEFAULT NULL,
     description CHAR(128) DEFAULT '' NOT NULL
 ) ENGINE=InnoDB;
 
diff --git a/scripts/mysql/subclient-create.sql b/scripts/mysql/subclient-create.sql
new file mode 100644
index 0000000..a2f47e4
--- /dev/null
+++ b/scripts/mysql/subclient-create.sql
@@ -0,0 +1,17 @@
+INSERT INTO version (table_name, table_version) values ('subclient','1');
+CREATE TABLE subclient (
+    id INT(10) UNSIGNED AUTO_INCREMENT PRIMARY KEY NOT NULL,
+    subserver CHAR(128) DEFAULT '' NOT NULL,
+    proxy CHAR(128) DEFAULT NULL,
+    aor CHAR(128) DEFAULT '' NOT NULL,
+    third_party_subclient CHAR(128) DEFAULT NULL,
+    username CHAR(64) DEFAULT NULL,
+    password CHAR(64) DEFAULT NULL,
+    binding_URI CHAR(128) DEFAULT '' NOT NULL,
+    binding_params CHAR(64) DEFAULT NULL,
+    expiry INT(1) UNSIGNED DEFAULT NULL,
+    forced_socket CHAR(64) DEFAULT NULL,
+    extra_headers CHAR(128) DEFAULT NULL,
+    CONSTRAINT aor_idx UNIQUE (aor)
+) ENGINE=InnoDB;
+
diff --git a/scripts/opensipsctl b/scripts/opensipsctl
index d8e787e..c379dc9 100755
--- a/scripts/opensipsctl
+++ b/scripts/opensipsctl
@@ -62,7 +62,10 @@ fi
 if [ -z $MYLIBDIR ] ; then
 	MYLIBDIR="/usr/local/lib/opensips/opensipsctl"
 	if [ ! -d $MYLIBDIR ]; then
-		MYLIBDIR=$MYDIR
+		MYLIBDIR="/usr/local/lib64/opensips/opensipsctl"
+		if [ ! -d $MYLIBDIR ]; then
+			MYLIBDIR=$MYDIR
+		fi
 	fi
 fi
 
@@ -2541,7 +2544,7 @@ tls_ca() {
 
 		mecho "Creating CA self-signed certificate"
 		( cd $CA_PATH; openssl req -config $CA_BASE/$CA_CONF -x509 -newkey \
-			rsa:2048 -days 365 -out ./cacert.pem -outform PEM )
+			rsa:$CABIT -out ./cacert.pem -outform PEM -passin env:CAPASS -passout env:CAPASS)
 		if [ $? -ne 0 ] ; then
 			merr "Failed to create self-signed certificate"
 			exit 1
@@ -2608,7 +2611,7 @@ tls_ca() {
 
 		mecho "Creating user certificate request"
 		openssl req  -config $USER_CFG -out $USER_DIR/$USER-cert_req.pem \
-			-keyout $USER_DIR/$USER-privkey.pem -new -nodes
+			-keyout $USER_DIR/$USER-privkey.pem -new -nodes -passin env:CAPASS -passout env:CAPASS
 		if [ $? -ne 0 ] ; then
 			merr "Failed to generate certificate request"
 			exit 1
@@ -2616,7 +2619,7 @@ tls_ca() {
 
 		mecho "Signing certificate request"
 		( cd $CA_BASE ; openssl ca -config $REQ_CFG -in \
-			$USER_DIR/$USER-cert_req.pem -out $USER_DIR/$USER-cert.pem )
+			$USER_DIR/$USER-cert_req.pem -out $USER_DIR/$USER-cert.pem -passin env:CAPASS)
 		if [ $? -ne 0 ] ; then
 			merr "Failed to generate certificate request"
 			exit 1
diff --git a/scripts/opensipsctlrc b/scripts/opensipsctlrc
index 3f4b30d..c8ee787 100644
--- a/scripts/opensipsctlrc
+++ b/scripts/opensipsctlrc
@@ -7,7 +7,7 @@
 # will use their internal default values.
 
 ## your SIP domain
-# SIP_DOMAIN=opensips.org
+SIP_DOMAIN=blox.org
 
 ## chrooted directory
 # $CHROOT_DIR="/path/to/chrooted/directory"
@@ -16,31 +16,28 @@
 ## by default none is loaded
 # If you want to setup a database with opensipsdbctl, you must at least specify
 # this parameter.
-# DBENGINE=MYSQL
-
-## database port (PostgreSQL=5432 default; MYSQL=3306 default)
-# DBPORT=3306
+DBENGINE=MYSQL
 
 ## database host
-# DBHOST=localhost
+DBHOST=localhost
 
 ## database name (for ORACLE this is TNS name)
-# DBNAME=opensips
+DBNAME=opensips_2_2
 
 # database path used by dbtext, db_berkeley, or sqlite
 # DB_PATH="/usr/local/etc/opensips/dbtext"
 
 ## database read/write user
-# DBRWUSER=opensips
+DBRWUSER=opensips
 
 ## password for database read/write user
-# DBRWPW="opensipsrw"
+DBRWPW="opensipsrw"
 
 ## engine type for the MySQL/MariaDB tabels (default InnoDB)
-# MYSQL_ENGINE="MyISAM"
+MYSQL_ENGINE="MyISAM"
 
 ## database super user (for ORACLE this is 'scheme-creator' user)
-# DBROOTUSER="root"
+DBROOTUSER="root"
 
 # user name column
 # USERCOL="username"
diff --git a/scripts/opensipsdbctl.base b/scripts/opensipsdbctl.base
index 81c9a9c..dd2c298 100644
--- a/scripts/opensipsdbctl.base
+++ b/scripts/opensipsdbctl.base
@@ -30,7 +30,7 @@ INSTALL_PRESENCE_TABLES=${INSTALL_PRESENCE_TABLES:-ask}
 # Used by dbtext and db_berkeley to define tables to be created, used by
 # postgres to do the grants
 STANDARD_TABLES=${STANDARD_TABLES:-version acc dbaliases domain grp uri speed_dial subscriber location re_grp address missed_calls usr_preferences aliases silo dialog dispatcher dialplan dr_gateways dr_rules dr_groups dr_carriers dr_partitions rtpproxy_sockets load_balancer clusterer tls_mgm }
-EXTRA_TABLES=${EXTRA_TABLES:-imc_members imc_rooms cpl sip_trace domainpolicy carrierroute route_tree carrierfailureroute userblacklist globalblacklist b2b_entities b2b_logic cachedb registrant cc_flows cc_agents cc_cdrs cc_calls fraud_detection emergency_routing emergency_report}
+EXTRA_TABLES=${EXTRA_TABLES:-imc_members imc_rooms cpl sip_trace domainpolicy carrierroute route_tree carrierfailureroute userblacklist globalblacklist b2b_entities b2b_logic cachedb registrant cc_flows cc_agents cc_cdrs cc_calls fraud_detection emergency_routing emergency_repor subclient }
 PRESENCE_TABLES=${PRESENCE_TABLES:-presentity active_watchers watchers xcap pua rls_presentity rls_watchers}
 
 # SQL definitions
@@ -61,7 +61,7 @@ SED=${SED:-sed}
 
 # define what modules should be installed
 STANDARD_MODULES=${STANDARD_MODULES:-standard acc domain group permissions registrar usrloc msilo alias_db uri_db rtpproxy speeddial avpops auth_db dialog dispatcher dialplan drouting load_balancer clusterer tls_mgm }
-EXTRA_MODULES=${EXTRA_MODULES:-imc cpl siptrace domainpolicy carrierroute userblacklist b2b cachedb_sql registrant call_center fraud_detection emergency}
+EXTRA_MODULES=${EXTRA_MODULES:-imc cpl siptrace domainpolicy carrierroute userblacklist b2b cachedb_sql registrant call_center fraud_detection emergency subclient }
 
 ############################################################
 
diff --git a/transformations.c b/transformations.c
index 77afe97..33bf2c4 100644
--- a/transformations.c
+++ b/transformations.c
@@ -2473,6 +2473,12 @@ char* tr_parse_string(str* in, trans_t *t)
 	} else if(name.len==11 && strncasecmp(name.s, "decode.hexa", 11)==0) {
 		t->subtype = TR_S_DECODEHEXA;
 		return p;
+	} else if(name.len==13 && strncasecmp(name.s, "encode.base64", 13)==0) {
+		t->subtype = TR_S_B64ENCODE;
+		return p;
+	} else if(name.len==13 && strncasecmp(name.s, "decode.base64", 13)==0) {
+		t->subtype = TR_S_B64DECODE;
+		return p;
 	} else if(name.len==7 && strncasecmp(name.s, "hex2dec", 7)==0) {
 		t->subtype = TR_S_HEX2DEC;
 		return p;
-- 
1.7.1

